# vutil.tcl
################################################################################
# Variable utilities for Tcl

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" for information on usage, redistribution, and for a 
# DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Define namespace
namespace eval ::vutil {
    # Define the types available (via "string is")
    namespace export default; # Set a variable if it does not exist
    namespace export lock unlock; # Hard set a Tcl variable
    namespace export tie untie; # Tie a Tcl variable to a Tcl object
    namespace export new; # Create new value container object
}

# BASIC VARIABLE UTILITIES
################################################################################

# default --
#
# Soft set of a variable. Only sets the variable if it does not exist.
#
# Syntax:
# default $varName $value
#
# Arguments:
# varName       Variable name
# value         Variable default value

proc ::vutil::default {varName value} {
    upvar 1 $varName myVar
    if {![info exists myVar]} {
        set myVar $value
    } else {
        set value $myVar
    }
    return $value
}

# lock --
#
# Hard set of a variable. locked variables cannot be modified by set or default.
# Cannot lock an entire array.
#
# Syntax:
# lock $varName <$value>
#
# Arguments:
# varName       Variable to lock
# value         Value to set

proc ::vutil::lock {varName args} {
    upvar 1 $varName myVar
    if {[array exists myVar]} {
        return -code error "cannot lock an array"
    }
    # Switch for arity (allow for self-tie)
    if {[llength $args] == 0} {
        if {[info exists myVar]} {
            set value $myVar
        } else {
            return -code error "can't read \"$varName\": no such variable"
        }
    } elseif {[llength $args] == 1} {
        set value [lindex $args 0]
    } else {
        return -code error "wrong # args: should be \"lock varName ?value?\""
    }
    # Remove any existing lock trace
    if {[info exists myVar]} {
        unlock myVar
    }
    # Set value and define lock trace
    set myVar $value
    trace add variable myVar write [list ::vutil::LockTrace $value]
    return $value
}

# unlock --
#
# Unlock defined variables
#
# Syntax:
# unlock $varName ...
#
# Arguments:
# varName...    Variables to unlock

proc ::vutil::unlock {args} {
    foreach varName $args {
        upvar 1 $varName myVar
        if {[array exists myVar]} {
            return -code error "cannot unlock an array"
        }
        if {![info exists myVar]} {
            return -code error "can't unlock \"$varName\": no such variable"
        }
        set value $myVar; # Current value
        trace remove variable myVar write [list ::vutil::LockTrace $value]
    }
    return
}

# LockTrace --
#
# Private procedure, used for enforcing locked value
# Prints warning to notify user that variable is locked
#
# Syntax:
# LockTrace $value $varName $index $op
#
# Arguments:
# value         Value to lock
# varName       Variable (or array) name
# index         Index of array if variable is array
# op            Trace operation (unused)

proc ::vutil::LockTrace {value varName index op} {
    upvar 1 $varName myVar
    if {[array exists myVar]} {
        set myVar($index) $value
        puts stderr "failed to modify \"${varName}($index)\": read-only"
    } else {
        set myVar $value
        puts stderr "failed to modify \"$varName\": read-only"
    }
}

# TCLOO GARBAGE COLLECTION
################################################################################

# tie --
# 
# Tie a variable to a Tcl object, such that when the reference variable is 
# modified, unset, or goes out of scope, that the object is destroyed as well.
#
# Syntax:
# tie $refName <$object>
#
# Arguments:
# refName       Reference variable representing object
# object        TclOO object

proc ::vutil::tie {refName args} {
    # Create upvar link to reference variable
    upvar 1 $refName ref
    if {[array exists ref]} {
        return -code error "cannot tie an array"
    }
    # Switch for arity (allow for self-tie)
    if {[llength $args] == 0} {
        if {[info exists ref]} {
            set object $ref
        } else {
            return -code error "can't read \"$refName\": no such variable"
        }
    } elseif {[llength $args] == 1} {
        set object [lindex $args 0]
    } else {
        return -code error "wrong # args: should be \"tie refName ?object?\""
    }
    
    # Verify that input is an object
    if {![info object isa object $object]} {
        return -code error "\"$object\" is not an object"
    }
    
    # Set variable to object (triggers any tie traces)
    set ref $object
    
    # Verify that assignment worked. 
    # If not, variable is locked to a different value.
    if {$ref ne $object} {
        return -code error "cannot tie \"$refName\": read-only"
    }
    
    # Create variable traces to destroy object upon write or unset of variable.
    # Also create command trace to prevent renaming of object.
    trace add variable ref {write unset} [list ::vutil::TieVarTrace $object]
    trace add command $object rename ::vutil::TieObjTrace
    
    # Return the value (like with "set")
    return $object
}

# untie --
# 
# Untie variables from their respective Tcl objects.
#
# Syntax:
# untie $varName ...
#
# Arguments:
# varName...    Variables to unlock

proc ::vutil::untie {args} {
    foreach refName $args {
        upvar 1 $refName ref
        if {![info exists ref]} {
            return -code error "can't untie \"$refName\": no such variable"
        }
        if {[array exists ref]} {
            return -code error "cannot untie an array"
        }
        RemoveTie ref $ref
    }
    return
}

# RemoveTie --
#
# Private command to remove tie traces from a variable
#
# Syntax:
# RemoveTie $varName $objName
# 
# Arguments:
# varName       Variable name to remove traces from
# objName       Name of object to remove them from

proc ::vutil::RemoveTie {refName object} {
    upvar 1 $refName ref
    trace remove variable ref {write unset} [list ::vutil::TieVarTrace $object]
    catch {trace remove command $object rename ::vutil::TieObjTrace}
}

# TieVarTrace --
#
# Removes traces and destroys associated Tcl object
#
# Syntax:
# TieVarTrace $object $refName $index $op
#
# Arguments:
# refName       Variable (or array) name
# index         Index of array if variable is array
# op            Trace operation (unused)

proc ::vutil::TieVarTrace {object refName index op} {
    upvar 1 $refName ref
    # Remove tie and return if setting to self
    if {[info exists ref]} {
        if {[array exists ref]} {
            RemoveTie ref($index) $object
            if {$ref($index) eq $object} {
                return
            }
        } else {
            RemoveTie ref $object
            if {$ref eq $object} {
                return
            }
        }
    }
    # Destroy the object if it still exists.
    if {[info object isa object $object]} {
        $object destroy
    }
}

# TieObjTrace --
#
# For some reason, the rename trace doesn't work well with TclOO objects.
# Instead, to ensure proper use, return a fatal error.

proc ::vutil::TieObjTrace {args} {
    puts stderr "FATAL: cannot rename tied objects"
    exit 2
}

# Garbage Collection Superclasses
################################################################################

# ::vutil::GarbageCollector --
#
# Superclass for objects with garbage collection. Not exported.
#
# Public methods:
# $object --> $refName      Copy object to new variable.

::oo::class create ::vutil::GarbageCollector {
    # Constructor ties object to gc variable.
    # Call "next $refName" in subclass constructor.    
    constructor {refName} {
        uplevel 1 [list ::vutil::tie $refName [self]]
    }
    
    # CopyObject (-->) --
    #
    # Copy object to new variable (returns new object name)
    #
    # Syntax:
    # my CopyObject $refName
    # $object --> $refName
    #
    # Arguments:
    # refName       Variable to copy to.
    
    method CopyObject {refName} {
        uplevel 1 [list ::vutil::tie $refName [oo::copy [self]]]
    }
    method --> {refName} {
        tailcall my CopyObject $refName
    }
    export -->
}

# ValueContainer --
#
# ValueContainer class.
# Value is stored within object variable "myValue".
# Type is stored within object variable "myType".
#
# Syntax:
# ValueContainer new $refName <$value> <$type>
#
# Arguments:
# refName       Reference variable for object.
# value         Value to initialize with. Default "".
# type          Type for data validation. Default "" for no validation.
#
# Public methods:
# $valueObj <value>           Returns value.
# $valueObj type              Get type.
# $valueObj = $value          Value assignment.
# $valueObj := $expr          Expression assignment.
# $valueObj | $arg ...        Evaluate methods in temp object, return result.
# $valueObj & $varName $body  Evaluate script to modify value.

::oo::class create ::vutil::ValueContainer {
    superclass ::vutil::GarbageCollector; # includes --> method
    variable myValue myType; # Value and type of object
    constructor {refName {value ""} {type ""}} {
        set myType $type
        my SetValue $value
        next $refName
    }
    
    # ValidateValue --
    # 
    # Validate value stored in object. 
    # Calls ::vutil::type::$myType.
    
    method ValidateValue {value} {
        if {$myType eq ""} {
            return $value
        }
        ::vutil::type::$myType $value
    }
    
    # GetType (type) --
    #
    # Return type of object.
    #
    # Syntax:
    # my GetType
    # $object type
    
    method GetType {} {
        return $myType
    }
    method type {} {
        my GetType
    }
    
    # GetValue (value, unknown) --
    # 
    # Get the value stored in the object.
    #
    # Syntax:
    # my GetValue
    # $object value
    # $object
    
    method GetValue {} {
        return $myValue
    }
    method value {} {
        my GetValue
    }
    method unknown {args} {
        if {[llength $args] == 0} {
            return [my GetValue]
        }
        next {*}$args
    }
    unexport unknown
    
    # SetValue (= :=) --
    #
    # Set the value stored in the object, and return object name.
    # For numeric and boolean types, setting to "blank" sets to default.
    #
    # Syntax:
    # my SetValue $value
    # $object = $value
    # $object := $expr
    # 
    # Arguments:
    # value         Value to set
    # expr          Math expression to evaluate.
    
    method SetValue {value} {
        set myValue [my ValidateValue $value]
        return [self]
    }
    method = {value} {
        my SetValue $value
    }
    method := {expr} {
        my SetValue [my Uplevel 1 [list expr $expr]]
    }
    export = :=
    
    # TempObject (|) --
    # 
    # Copy to temp object, evaluate method, and return object value or result.
    #
    # Syntax:
    # my TempObject $method $arg ...
    # $object | 
    # 
    # Arguments:
    # method        Method name
    # arg ...       Arguments for method
    
    method TempObject {method args} {
        my CopyObject temp
        set result [uplevel 1 [list $temp $method {*}$args]]
        if {$result eq $temp} {
            set result [$temp]
        }
        return $result
    }
    method | {method args} {
        tailcall my TempObject $method {*}$args
    }
    export |
    
    # RefEval (&) --
    #
    # Evaluate a command, using a temporary variable for the object value.
    # Unsetting the temporary variable will destroy the object.
    # Modifications will be applied at the end of the script.
    #
    # Syntax:
    # my RefEval $varName $body 
    # $object & $varName $body
    #
    # Arguments:
    # varName       Variable name to access raw value with.
    # body          Body to evaluate.
    
    method RefEval {varName body} {
        upvar 1 $varName var
        set var [my GetValue]
        try {
            my Uplevel 1 $body; # establishes "$" alias as well
        } finally {
            if {![info exists var]} {
                my destroy
            } elseif {$var ne [my GetValue]} {
                my SetValue $var
                unset var
            }
        }
    }
    method & {varName body} {
        tailcall my RefEval $varName $body
    }
    export &
    
    # Uplevel --
    # 
    # Evaluate the script in the caller, creating an alias ($) for the object.
    # Used with operator :=
    #
    # Syntax:
    # my Uplevel $level $body
    #
    # Arguments:
    # level         Level to evaluate at
    # body          Script to evaluate
    
    method Uplevel {level body} {
        # Set up alias for self.
        set oldAlias [interp alias {} $]
        interp alias {} $ {} [self]
        # Evaluate script, and, finally, reset alias.
        try {
            uplevel [incr level] $body
        } finally {
            interp alias {} $ {} {*}$oldAlias
        }
    }
}

# new --
#
# Declare a new value container object, using the ValueContainer superclass.
#
# Syntax:
# new <$type> $refName <= $value>
# 
# Arguments:
# type          Type for validation. See ::vutil::type namespace.
# refName       Reference variable name.
# value         Value to assign to variable. Optional.

proc ::vutil::new {args} {
    # Check arity. Must be 1,2,3, or 4 args.
    if {[llength $args] == 0 || [llength $args] > 4} {
        return -code error "wrong # args: should be\
                \"new ?type? refName ?= value?\""
    }
    # Assignment case
    if {[llength $args] % 2} {
        set type ""
        set args [lassign $args refName]
    } else {
        set args [lassign $args type refName]
    }
    # Assign default values.
    if {[llength $args] == 0} {
        set value [type::$type]; # Get default for type
    } elseif {[lindex $args 0] eq "="} {
        set value [lindex $args end]
    } else {
        return -code error "bad syntax: want \"new ?type? refName = value\""
    }
    # Call ValueContainer constructor
    tailcall ValueContainer new $refName $value $type
}

# Type library
################################################################################
namespace eval ::vutil::type {}

# double --
# Double-precision floating point number. Default 0.0

proc ::vutil::type::double {{value 0.0}} {
    ::tcl::mathfunc::double $value
}

# int --
# 32-bit integer value. Default 0

proc ::vutil::type::int {{value 0}} {
    ::tcl::mathfunc::int $value
}

# wide --
# 64-bit integer value. Default 0

proc ::vutil::type::wide {{value 0}} {
    ::tcl::mathfunc::wide $value
}

# entier --
# Big integer value. Default 0

proc ::vutil::type::entier {{value 0}} {
    ::tcl::mathfunc::entier $value
}

# bool --
# Boolean value. Default 0

proc ::vutil::type::bool {{value 0}} {
    ::tcl::mathfunc::bool $value
}

# list --
# Tcl list. Default ""

proc ::vutil::type::list {{value ""}} {
    if {![string is list $value]} {
        return -code error "expected list, got \"$value\""
    }
    return $value
}

# dict --
# Tcl dictionary. Default ""

proc ::vutil::type::dict {{value ""}} {
    if {[catch {dict size $value}]} {
        return -code error "expected dict, got \"$value\""
    }
    return $value
}

# Finally, provide the package
package provide vutil @VERSION@
