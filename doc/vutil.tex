\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}

% Other macros

\title{\Huge Tcl Variable Utilities\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/vutil}}
\date{\small\today}
\makeindex[columns=2,title={Command Index}]
\begin{document}
\maketitle
\begin{abstract}
\begin{center}
This package provides various utilities for working with variables in Tcl, including read-only variables, TclOO garbage collection, and an object-variable type system.
\end{center}
\end{abstract}

\clearpage
\section{Default Values}
The command \cmdlink{default} assigns values to variables if they do not exist.
\begin{syntax}
\command{default} \$varName \$value
\end{syntax}
\begin{args}
\$varName & Name of variable to set \\
\$value & Default value for variable
\end{args}

The example below shows how default values are only applied if the variable does not exist.
\begin{example}{Variable defaults}
\begin{lstlisting}
set a 5
default a 7; # equivalent to "if {![info exists a]} {set a 7}"
puts $a
unset a
default a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
7
\end{lstlisting}
\end{example}
\clearpage
\section{Variable Locks}
The command \cmdlink{lock} uses Tcl variable traces to make a read-only variable. 
If attempting to modify a locked variable, it will throw a warning, but not an error.

\begin{syntax}
\command{lock} \$varName <\$value>
\end{syntax}
\begin{args}
\$varName & Variable name to lock.  \\
\$value & Value to lock variable at. Default self-locks (uses current value).
\end{args}

The command \cmdlink{unlock} unlocks previously locked variables so that they can be modified again.
\begin{syntax}
\command{unlock} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to unlock.
\end{args}

\begin{example}{Variable locks}
\begin{lstlisting}
lock a 5
set a 7; # throws warning to stderr channel
puts $a
unlock a
set a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
failed to modify "a": read-only
5
7
\end{lstlisting}
\end{example}

Note: You can lock array elements, but not an entire array.

\clearpage

\section{Variable-Object Ties}
As of Tcl version 8.6, there is no garbage collection for Tcl objects, they have to be removed manually with the ``destroy'' method. 
The command \cmdlink{tie} is a solution for this problem, using variable traces to destroy the corresponding object when the variable is unset or modified. 
For example, if an object is tied to a local procedure variable, the object will be destroyed when the procedure returns.


\begin{syntax}
\command{tie} \$refName <\$object>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$object & Object to tie variable to. Default self-ties (uses current value).
\end{args}

In similar fashion to \cmdlink{unlock}, tied variables can be untied with the command \cmdlink{untie}.
\begin{syntax}
\command{untie} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to untie.
\end{args}

\begin{example}{Variable-object ties}
\begin{lstlisting}
oo::class create foo {
    method hi {} {
        puts hi
    }
}
tie a [foo create bar]
set b $a; # alias variable
unset a; # triggers ``destroy''
$b hi; # throws error
\end{lstlisting}
\tcblower
\begin{lstlisting}
invalid command name "::bar"
\end{lstlisting}
\end{example}

Note: You can tie array elements, but not an entire array, and you cannot tie a locked variable.
\clearpage
\subsection{Reference Variables}
Valid reference variables for the \cmdlink{tie} command must match the following regular expression:
\begin{lstlisting}
(::+|\w+)+(\(\w+\))?
\end{lstlisting}
The one exception to this rule is the shared global reference variable ``\textbf{\texttt{\&}}''.
This shared reference, regardless of scope, can be accessed with the command ``\textbf{\texttt{\cmdlink{\$\&}}}''.
\begin{syntax}
\command{\$\&} \$arg ...
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

\subsubsection{Reference Parser API}
The command \cmdlink{::vutil::RefSub}, which performs ``\texttt{\$@ref}'' substitution on a given string, returning the updated string and all matched reference names. 
For example, ``\texttt{\$@ref}'' is converted to ``\texttt{\$\{::@(ref)\}}'': an element of the global array variable ``\texttt{@}''.
To escape a reference, especially for nested substitution, simply add more ``\texttt{@}'' symbols, like ``\texttt{\$@@ref}''.
This command is not exported, as it is intended for use by developers.
\begin{syntax}
\command{::vutil::RefSub} \$string
\end{syntax}
\begin{args}
\$string & String to perform substitution with.
\end{args}

There are two special references: ``\texttt{\$@\&}'' and ``\texttt{\$@.}''. Both refer to the global variables ``\texttt{\&}'' and ``\texttt{.}'', respectively, and they are always listed first in the reference variable list, as shown in the example below:
\begin{example}{Reference variable substitution}
\begin{lstlisting}
lassign [::vutil::RefSub {$@& + $@x(1) - $@@y + $@.}] string refs
puts $string
puts $refs
\end{lstlisting}
\tcblower
\begin{lstlisting}
${::@(::&)} + ${::@(x(1))} - $@y + ${::@(::.)}
::& ::. x(1)
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{Garbage Collection Superclass}
The class ``\texttt{\command{::vutil::GC}}'' is a TclOO superclass that includes garbage collection. 
This class is not exported, and not intended for direct use, as it is simply a template for classes with built-in garbage collection, by tying the object to a specified reference variable using \cmdlink{tie}.
In addition to tying the object to a reference variable in the superclass constructor, the ``\texttt{::vutil::GC}'' superclass also provides a method for copying the object to a new reference variable: ``\texttt{-{}->}''.
\begin{syntax}
\$obj -{}-> \$refName
\end{syntax}
\begin{args}
\$obj & Object that inherits the ``\texttt{::vutil::GC}'' superclass. \\
\$refName & Name of reference variable for garbage collection.
\end{args}

Below is an example of how this superclass can be used to build garbage collection into a TclOO class. 
\begin{example}{Creating a class with garbage collection}
\begin{lstlisting}
oo::class create container {
    superclass ::vutil::GC
    variable myValue
    constructor {refName value} {
        set myValue $value
        next $refName
    }
    method set {value} {set myValue $value}
    method value {} {return $myValue}
}
proc wrap {value} {
    container new & $value
    return $&
}
[wrap {hello world}] --> x
puts [$x value]
unset x; # also destroys object
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
\end{lstlisting}
\end{example}
\clearpage
\section{Object Variable Class}
The TclOO class \cmdlink{var} is a subclass of ``\texttt{::vutil::GC}'' that acts as a container class for data, so that calling the object variable by itself (e.g. \texttt{[\$varObj]}) returns the value stored in the object.
\begin{syntax}
\command{var} new \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$value & Value to set object variable to. Default blank.
\end{args}

\subsection{Standard Object Variable Operators}
The operator method ``\texttt{\methodlink[0]{var}{=}}'' assigns the value of the object variable, returning the name of the object.
The operator method ``\texttt{\methodlink[0]{var}{<-}}'' assigns the value and any object metadata directly from another object variable of the same class, returning the name of the object.
The operator method ``\texttt{\methodlink[0]{var}{-{}->}}'' copies the object variable to a new reference variable, returning the name of the new object.
\begin{syntax}
\method{var}{=} \$value
\end{syntax}
\begin{syntax}
\method{var}{<-} \$otherVarObj 
\end{syntax}
\begin{syntax}
\method{var}{-{}->} \$refName
\end{syntax}
\begin{args}
\$value & Value to set object variable to. \\
\$otherVarObj & Other object variable to assign value from (must be same class). \\
\$refName & Name of reference variable for garbage collection.
\end{args}

The example below demonstrates the myriad of ways object variables can be manipulated:
\begin{example}{Standard object variable operators}
\begin{lstlisting}
var new x; # Create blank object variable $x
[$x --> y] = 2; # Copy $x to $y, and set to 2
[var new z] <- [$x <- $y]; # Create $z and set to $x after setting $x to $y.
puts [list [$x] [$y] [$z]]
\end{lstlisting}
\tcblower
\begin{lstlisting}
2 2 2
\end{lstlisting}
\end{example}


\clearpage
\subsection{Advanced Object Variable Operators}
The operator methods ``\texttt{\methodlink[0]{var}{.=}}'', ``\texttt{\methodlink[0]{var}{:=}}'', and ``\texttt{\methodlink[0]{var}{::=}}'' are similar to the operator method ``\texttt{\methodlink[0]{var}{=}}'', except that they can perform a transformation on the existing value of the object variable. 
\begin{syntax}
\method{var}{.=} \$oper
\end{syntax}
\begin{syntax}
\method{var}{:=} \$expr
\end{syntax}
\begin{syntax}
\method{var}{::=} \$body
\end{syntax}
\begin{args}
\$oper & Tcl math operator and additional mathop arguments, i.e. \texttt{"+ 5"}. \\
\$expr & Tcl expression to evaluate, passing input through the Tcl \textit{expr} command. \\
\$body & Tcl script to evaluate.
\end{args}

The operator ``\texttt{\methodlink[0]{var}{.=}}'' passes the value of the object as the first argument in the corresponding Tcl mathop command, allowing for modification in reference to the current value.
Similarly, the operators ``\texttt{\methodlink[0]{var}{:=}}'' and ``\texttt{\methodlink[0]{var}{::=}}'', allow for object self-reference using the command ``\cmdlink{\$.}'', which accesses the global read-only self-reference variable ``\texttt{.}''.
\begin{syntax}
\command{\$.} <\$arg ...>
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

The example below demonstrates how you can use these features to manipulate object variables.
\begin{example}{Advanced object variable operators}
\begin{lstlisting}
var new x 5.0; # Create variable $x
[[var new y] <- $x] .= {+ 10}; # Create new variable y, set to x, and add 10.
set p 2; # Create primative variable
$y := {[$.] ** $p + [$x]}; # Square y, plus $x (230.0) (accesses $p)
$y ::= {split [$.] .}; # Split at decimal (230 0)
puts [$y]
\end{lstlisting}
\tcblower
\begin{lstlisting}
230 0
\end{lstlisting}
\end{example}

\clearpage
\subsection{Object Variable Metadata}
The method \methodlink[0]{var}{info} accesses all object variable metadata. 
Fields ``type'' and ``value'' are standard.
\begin{syntax}
\method{var}{info} <\$field>
\end{syntax}
\begin{args}
\$field & Info field to get. Default returns dictionary of all info. \\
\end{args}

\subsection{Printing an Object Variable Value}
The method \methodlink[0]{var}{print} prints the value of the variable to screen or file.
\begin{syntax}
\method{var}{print} <-nonewline> <\$channelID>
\end{syntax}
\begin{args}
-nonewline & Option to print without newline. \\
\$channelID & Channel ID open for writing. Default stdout.
\end{args}

\subsection{Destroying an Object Variable}
Because object variables are simply TclOO objects, they can be destroyed with the standard method \methodlink[0]{var}{destroy}. 
Additionally, unsetting the linked variable will also destroy the object.
\begin{syntax}
\method{var}{destroy} \\
unset \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable used for garbage collection.
\end{args}

\begin{example}{Standard object variable methods}
\begin{lstlisting}
var new x {Hello World}
puts [$x info]
$x print
$x destroy; # or "unset x"
\end{lstlisting}
\tcblower
\begin{lstlisting}
type var value {Hello World}
Hello World
\end{lstlisting}
\end{example}

\clearpage
\section{Object Variable Types}
The TclOO class \cmdlink{var} acts as a superclass for a pure-Tcl type system. Type classes are created and managed through the command ensemble \cmdlink{type}.
\begin{syntax}
\command{type} \$subcommand \$arg ...
\end{syntax}
\begin{args}
\$subcommand & Subcommand name. \\
\$arg ... & Arguments for subcommand.
\end{args}

New type classes can be created using the subcommands \subcmdlink[0]{type}{new} or \subcmdlink[0]{type}{create}.
Both subcommands create a class that is a subclass of ``\texttt{::vutil::var}'', with a private method \textit{Type} that returns the corresponding type.
If creating a type class with the subcommand \subcmdlink[0]{type}{new}, the resulting class will be named ``\texttt{::vutil::type.\$type}''.
\begin{syntax}
\subcommand{type}{new} \$type \$defScript \\
\subcommand{type}{create} \$type \$name \$defScript
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$name & Name of class. \\
\$defScript & Class definition script. 
\end{args}

Note: The value of the object variable is stored in the blank array name ``value''. 
The blank array is used to store all the object variable properties, and is what is returned with the method ``info''.
By default, from the superclass ``\texttt{::vutil::var}'', there are two properties: (value) and (type).

\clearpage
\subsection{Type Queries}
A list of all defined types can be queried with the subcommand \subcmdlink[0]{type}{names}. 
\begin{syntax}
\subcommand{type}{names}
\end{syntax}

The existence of a type can be queried with the subcommand \subcmdlink[0]{type}{exists}, and 
the class associated with a type can be queried with the subcommand \subcmdlink[0]{type}{class}. 
\begin{syntax}
\subcommand{type}{exists} \$type
\end{syntax}
\begin{syntax}
\subcommand{type}{class} \$type
\end{syntax}
\begin{args}
\$type & Name of type. 
\end{args}

The subcommand \subcmdlink[0]{type}{isa} checks if an object is of a specific type or of one of its subtypes.
If the type or object does not exist, this command will return an error.
Similarly, the subcommand \subcmdlink[0]{type}{assert} returns an error if an object is not of a specific type or of one its subtypes.

\begin{syntax}
\subcommand{type}{isa} \$type \$object
\end{syntax}
\begin{syntax}
\subcommand{type}{assert} \$type \$object
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$object & Name of object.
\end{args}

\clearpage
\section{Basic Type Library}
This package provides a few basic object variable types: \subcmdlink[0]{new}{var}, \subcmdlink[0]{new}{string}, \subcmdlink[0]{new}{bool}, \subcmdlink[0]{new}{int} and  \subcmdlink[0]{new}{float}.

\subsection{Creating Type Variables}
Classes defined by \cmdlink{type} only have the constructor method \textit{new}, so as a convenience, the command \cmdlink{new} creates a new variable object of a specified type. If the reference name provided is blank, it will simply return the value after passing it through the datatype's data validation.

\begin{syntax}
\command{new} \$type \$refName <\$value>
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$refName & Name of reference variable to tie to object. Blank to return value. \\
\$value & Value to set object variable to (default varies).
\end{args}

\subsection{Type ``var'' (object variable)}
The type ``\subcmdlink[0]{new}{var}'' is just an alternative way to create an object variable (same syntax as ``new'' method for \cmdlink{var} class).
It is the superclass for all other types.
\begin{syntax}
\subcommand{new}{var} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Value to set object variable to (default blank).
\end{args}
\begin{example}{Basic object variable}
\begin{lstlisting}
new var a
puts [$a info]
[$a = foobar] print
\end{lstlisting}
\tcblower
\begin{lstlisting}
type var value {}
foobar
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``string''}
The type ``\subcmdlink[0]{new}{string}'' does not do any validation on input (because in Tcl, ``everything is a string''), adds the field ``length'' to the object info, and provides convenient methods for string processing.
\begin{syntax}
\subcommand{new}{string} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & String value (default blank).
\end{args}
The method \methodlink[0]{string}{length} returns the string length. This is the same as ``\texttt{\$stringObj info length}''.
\begin{syntax}
\method{string}{length}
\end{syntax}
The method \methodlink[0]{string}{append} simply appends values to the string.
\begin{syntax}
\method{string}{append} \$value ...
\end{syntax}
\begin{args}
\$value ... & String values to append.
\end{args}
The method ``\texttt{\methodlink[0]{string}{@}}'' can be used for string indexing and modification. 
If indexing, it will return the value, and if modifying, it will return the object.
\begin{syntax}
\protect\hypertarget{\$stringObj @}{\$stringObj @}\index{string methods!"@} \$first <\$last> <= \$newstring>
\end{syntax}
\begin{args}
\$first & First index in range. \\
\$last & Last index in range (default \texttt{\$first}). \\
\$newstring & Value to replace with. Default just returns the string index/range.
\end{args}

\begin{example}{String type example}
\begin{lstlisting}
new string x hello
$x append { world}
puts [$x length]
[$x @ 0 = H] print
\end{lstlisting}
\tcblower
\begin{lstlisting}
11
Hello world
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``bool'' (boolean)}
The type ``\subcmdlink[0]{new}{bool}'' validates input by passing it through the Tcl \textit{::tcl::mathfunc::bool} command, which ensures that the input is a valid boolean (0 or 1).
\begin{syntax}
\subcommand{new}{bool} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Boolean value (default 0).
\end{args}
The method  ``\texttt{\methodlink[0]{bool}{?}}'' provides a shorthand if-statement control flow method.
\begin{syntax}
\method{bool}{?} \$body1 <":" \$body2> 
\end{syntax}
\begin{args}
\$body1 & Body to evaluate if boolean is true. \\
\$body2 & Body to evaluate if boolean is false (optional, required with ``\texttt{:}'' keyword).
\end{args}

\begin{example}{Boolean type example}
\begin{lstlisting}
# Procedure with type validation
proc foo {a b c} {
    new string a $a
    new string b $b
    new bool c $c
    $c ? $a : $b
}
puts [foo hello world true]; # hello
puts [foo hello world false]; # world
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello
world
\end{lstlisting}
\end{example}
\clearpage
\subsection{Type ``int'' (integer)}
The type ``\subcmdlink[0]{new}{int}'' validates that the input is a valid integer, and additionally has increment/decrement methods.
\begin{syntax}
\subcommand{new}{int} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Integer value (default 0).
\end{args}
The methods ``\texttt{\methodlink[0]{int}{++}}'' and ``\texttt{\methodlink[0]{int}{-{}-}}'', simply increment/decrement the integer object by 1, and return the object.
\begin{syntax}
\method{int}{++} 
\end{syntax}
\begin{syntax}
\method{int}{-{}-} 
\end{syntax}
The methods ``\texttt{\methodlink[0]{int}{+=}}'', ``\texttt{\methodlink[0]{int}{-=}}'', ``\texttt{\methodlink[0]{int}{*=}}'' and ``\texttt{\methodlink[0]{v}{/=}}'' add, subtract, multiply, and perform integer division on the current value of the object variable.
Like the \texttt{\methodlink[0]{var}{:=}} method, it returns the object name.
\begin{syntax}
\method{int}{+=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{-=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{*=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{/=} \$expr
\end{syntax}
\begin{args}
\$expr & Expression to evaluate (passes through the ``\texttt{\methodlink[0]{var}{:=}}'' method).
\end{args}

\begin{example}{Integer example}
\begin{lstlisting}
for {new int i} {[$i] < 4} {$i ++} {
    $i print
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
0
1
2
3
\end{lstlisting}
\end{example}
\clearpage

\subsection{Type ``float'' (double-precision floating-point decimal)}
The type ``\subcmdlink[0]{new}{float}'' validates that input is a double-precision floating-point number, passing input through the Tcl \textit{::tcl::mathfunc::double} command.
\begin{syntax}
\subcommand{new}{float} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Float value (default 0.0).
\end{args}
The methods ``\texttt{\methodlink[0]{float}{+=}}'', ``\texttt{\methodlink[0]{float}{-=}}'', ``\texttt{\methodlink[0]{float}{*=}}'' and ``\texttt{\methodlink[0]{float}{/=}}'' add, subtract, multiply, and perform division on the current value of the object variable.
Like the \texttt{\methodlink[0]{var}{:=}} method, it returns the object name.
\begin{syntax}
\method{float}{+=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{-=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{*=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{/=} \$expr
\end{syntax}
\begin{args}
\$expr & Expression to evaluate (passes through ``\texttt{\methodlink[0]{var}{:=}}'' method).
\end{args}

\begin{example}{Float example}
\begin{lstlisting}
# Harmonic mean of two numbers (converts to float)
proc hmean {x y} {
    new float x $x
    new float y $y
    [new float z] := {2*[$x]*[$y]}
    if {[$z] != 0} {
        $z /= {[$x] + [$y]}
    }
    return [$z]
}
puts [hmean 1 2]; # 1.3333
\end{lstlisting}
\tcblower
\begin{lstlisting}
1.3333333333333333
\end{lstlisting}
\end{example}

\clearpage
\printindex
\end{document}
































