\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}
\renewcommand{\cleartooddpage}[1][]{\ignorespaces} % single side
\newcommand{\caret}{$^\wedge$}

% Other macros

\title{\Huge Tcl Variable Utilities\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/vutil}}
\date{\small\today}
\makeindex[columns=2,title={Command Index}]
\begin{document}
\maketitle
\begin{abstract}
\begin{center}
This package provides various utilities for working with variables in Tcl, including read-only variables, TclOO garbage collection, and an object-variable type system.
\end{center}
\end{abstract}
\clearpage
\section{Initializing Local Namespace Variables}
The command \cmdlink{local} is the counterpart to the Tcl \textit{global} command, and creates local variables linked to variables in the current namespace, by simply calling the Tcl \textit{variable} command multiple times.
\begin{syntax}
\command{local} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Name(s) of variables to initialize
\end{args}
\begin{example}{Access namespace variables in a procedure}
\begin{lstlisting}
# Define global variables
global a b c
set a 1
set b 2
set c 3
namespace eval ::foo {
    # Define local variables
    local a b c
    set a 4
    set b 5
    set c 6
}
proc ::foo::bar1 {} {
    # Access global variables
    global a b c
    list $a $b $c
}
proc ::foo::bar2 {} {
    # Access local variables
    local a b c
    list $a $b $c
}
puts [::foo::bar1]; # global a b c
puts [::foo::bar2]; # local a b c
\end{lstlisting}
\tcblower
\begin{lstlisting}
1 2 3
4 5 6
\end{lstlisting}
\end{example}

\clearpage

\section{Default Values}
The command \cmdlink{default} assigns values to variables if they do not exist. 

\begin{syntax}
\command{default} \$varName \$value
\end{syntax}
\begin{args}
\$varName & Name of variable to set \\
\$value & Default value for variable
\end{args}

The example below shows how default values are only applied if the variable does not exist.

\begin{example}{Variable defaults}
\begin{lstlisting}
set a 5
default a 7; # equivalent to "if {![info exists a]} {set a 7}"
puts $a
unset a
default a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
7
\end{lstlisting}
\end{example}
\clearpage
\section{Variable Locks}
The command \cmdlink{lock} uses Tcl variable traces to make a read-only variable. 
This is especially useful for controlling a parameter study of an analysis from a top-level.
If attempting to modify a locked variable, it will throw a warning, but not an error.
You can lock array elements, but not an entire array.

\begin{syntax}
\command{lock} \$varName <\$value>
\end{syntax}
\begin{args}
\$varName & Variable name to lock.  \\
\$value & Value to lock variable at. Default self-locks (uses current value).
\end{args}

The command \cmdlink{unlock} unlocks previously locked variables so that they can be modified again.

\begin{syntax}
\command{unlock} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to unlock.
\end{args}

\begin{example}{Variable locks}
\begin{lstlisting}
lock a 5
set a 7; # throws warning to stderr channel
puts $a
unlock a
set a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
failed to modify "a": read-only
5
7
\end{lstlisting}
\end{example}

\clearpage

\section{Variable-Object Ties}
As of Tcl version 8.6, there is no garbage collection for Tcl objects, they have to be removed manually with the ``destroy'' method. 
The command \cmdlink{tie} is a solution for this problem, using variable traces to destroy the corresponding object when the variable is unset or modified. 
For example, if an object is tied to a local procedure variable, the object will be destroyed when the procedure returns.
You can tie array elements, but not an entire array.

\begin{syntax}
\command{tie} \$refName <\$object>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$object & Object to tie variable to. Default self-ties (uses current value).
\end{args}

In similar fashion to \cmdlink{unlock}, tied variables can be untied with the command \cmdlink{untie}.
\begin{syntax}
\command{untie} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to untie.
\end{args}

\begin{example}{Variable-object ties}
\begin{lstlisting}
oo::class create foo {
    method hi {} {
        puts hi
    }
}
tie a [foo create bar]
set b $a; # alias variable
unset a; # triggers ``destroy''
$b hi; # throws error
\end{lstlisting}
\tcblower
\begin{lstlisting}
invalid command name "::bar"
\end{lstlisting}
\end{example}
\clearpage
\subsection{Reference Variables}
Valid reference variables for the \cmdlink{tie} command must match the following regular expression:
\begin{lstlisting}
(::+|\w+)+(\(\w+\))?
\end{lstlisting}
The one exception to this rule is the shared global reference variable ``\textbf{\texttt{\&}}''.
This shared reference, regardless of scope, can be accessed with the command ``\textbf{\texttt{\cmdlink{\$\&}}}''.
\begin{syntax}
\command{\$\&} \$arg ...
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

Reference variables can also be referred to with the ``\texttt{\$@ref}'' syntax in the context of iterator functions. 
The engine for this is the command \cmdlink{::vutil::refsub}, which performs ``\texttt{\$@ref}'' substitution on a given string, returning the updated string and all matched reference names. 
For example, ``\texttt{\$@ref}'' is converted to ``\texttt{\$::vutil::at(ref)}''.
To escape a reference, especially for nested substitution, simply add more ``\texttt{@}'' symbols, like ``\texttt{\$@@ref}''.
\begin{syntax}
\command{::vutil::refsub} \$string
\end{syntax}
\begin{args}
\$string & String to perform substitution with.
\end{args}

There are two special references: ``\texttt{\$@\&}'' and ``\texttt{\$@\.}''. Both refer to the global variables ``\texttt{\&}'' and ``\texttt{.}'', respectively, and they are always listed first in the reference variable list, as shown in the example below:
\begin{example}{Reference variable substitution}
\begin{lstlisting}
lassign [::vutil::refsub {$@& + $@x(1) - $@@y + $@.}] string refs
puts $string
puts $refs
\end{lstlisting}
\tcblower
\begin{lstlisting}
$::vutil::at(::&) + $::vutil::at(x(1)) $@y $::vutil::at(::.) 
::& ::. x(1)
\end{lstlisting}
\end{example}
A simple example of this is provided for the \subcmdlink[0]{new}{list} type, with the commands \cmdlink{leval} and \cmdlink{lexpr}, which allow you to write scripts or math expressions that automatically map over lists.

\clearpage
\subsection{Garbage Collection Superclass}
The class \cmdlink{gcoo} is a TclOO superclass that includes garbage collection. 
This class is not exported, and not intended for direct use, as it is simply a template for classes with built-in garbage collection.
The constructor is configured as shown below, and ties the object to the specified reference variable, using \cmdlink{tie}.
\begin{syntax}
::vutil::\command{gcoo} new \$refName \\
::vutil::gcoo create \$name \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$name & Name of object.
\end{args}

In addition to tying the object to a reference variable in the superclass constructor, the \cmdlink{::vutil::gcoo} superclass also provides a method for copying the object to a new reference variable: ``\texttt{\methodlink[0]{gcoo}{-{}->}}''.
\begin{syntax}
\method{gcoo}{-{}->} \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection.
\end{args}

Below is an example of how this superclass can be used to build garbage collection into a TclOO class. 
\begin{example}{Creating a class with garbage collection}
\begin{lstlisting}
oo::class create container {
    superclass ::vutil::gcoo
    variable myValue
    constructor {refName value} {
        set myValue $value
        next $refName
    }
    method set {value} {set myValue $value}
    method value {} {return $myValue}
}
proc wrap {value} {
    container new & $value
    return $&
}
[wrap {hello world}] --> x
puts [$x value]
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
\end{lstlisting}
\end{example}

\clearpage
\section{Variable-Object Links}
The command \cmdlink{link} links a global variable to a TclOO object, using the name of the object as the variable name. 
The value of the linked object variable is accessed by calling the TclOO object with no arguments (the ``unknown'' method), and writing to the object-variable calls the object's ``\texttt{=}'' method. 
Unsetting the linked object variable also calls the object's ``destroy'' method, and destroying the object unsets the linked object variable.
Linked object-variables are unlinked when the object is destroyed, but can also be unlinked with the command \cmdlink{unlink}.
\begin{syntax}
\command{link} \$object
\end{syntax}
\begin{syntax}
\command{unlink} \$object …
\end{syntax}
\begin{args}
\$object … & Object(s) to link/unlink.
\end{args}
\begin{example}{Linking an object variable}
\begin{lstlisting}
::oo::class create number {
    variable value
    constructor {args} {
        set value [uplevel 1 expr $args]
    }
    method unknown {args} {
        if {[llength $args] == 0} {
            return $value
        }
        next {*}$args
    }
    unexport unknown
    method = {args} {
        set value [uplevel 1 expr $args]
    }
    export =
}
link [tie a [number new 5]]; # garbage collection and obj-var link
puts [$a]; # 5
$a = 10 * [$a]
puts [$a]; # 50
incr $a
puts [subst $$a]; # 51
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
50
51
\end{lstlisting}
\end{example}
\clearpage
\section{Object Variable Class}
The TclOO class \cmdlink{var} is a subclass of \cmdlink{::vutil::gcoo}, that also sets up an object variable link with \cmdlink{link}. 
So, in addition to the copy method ``\texttt{\methodlink[0]{gcoo}{-{}->}}'', object variables can be manipulated directly with Tcl commands, and calling the object variable directly as a command with no arguments (e.g. \texttt{[\$varObj]}) returns the object variable value.

\begin{syntax}
\command{var} new \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable. \\
\$value & Value to set object variable to. 
\end{args}

\begin{example}{Object variables with garbage collection}
\begin{lstlisting}
# Example showing how object variables behave in procedures
proc foo {value} {
    # Create object with reference variable "result"
    var new result $value
    append $result { world}
    return [list $result [$result]]; # Returns name and value of object
}
set result [foo hello]; # Not the same "result"
lassign $result name value
puts $value; # hello world
puts [info object isa object $name]; # 0 (object was deleted when procedure returned)
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
0
\end{lstlisting}
\end{example}

\subsection{Destroying an Object Variable}
Because object variables are simply TclOO objects, they can be destroyed with the standard method \methodlink[0]{var}{destroy}. 
Additionally, unsetting the linked variable or the object variable will also destroy the object.
\begin{syntax}
\method{var}{destroy}
\end{syntax}


\clearpage
\subsection{Metadata Methods}
Additional information about the object variable can be accessed with object variable methods:

The method \methodlink[0]{var}{info} accesses all object variable metadata. 
Fields ``exists'' and ``type'' always exist, and ``value'' is populated when the variable is initialized.
\begin{syntax}
\method{var}{info} <\$field>
\end{syntax}
\begin{args}
\$field & Info field to get. Default returns dictionary of all info. \\
\end{args}

The method \methodlink[0]{var}{print} is a short-hand way to print the value of the variable to screen.
\begin{syntax}
\method{var}{print} <-nonewline> <\$channelID>
\end{syntax}
\begin{args}
-nonewline & Option to print without newline. \\
\$channelID & Channel ID open for writing. Default stdout.
\end{args}
\begin{example}{Printing the value of a variable}
\begin{lstlisting}
var new x {Hello World}
puts [$x info]
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
exists 1 type var value {Hello World}
Hello World
\end{lstlisting}
\end{example}


\clearpage
\subsection{Standard Assignment Operators}
In addition to being able to manipulate object variables directly with Tcl commands, variables can also be manipulated with object variable operators.
The operator method ``\texttt{\methodlink[0]{var}{=}}'' assigns the value directly, and the operator method ``\texttt{\methodlink[0]{var}{<-}}'' assigns the value and metadata directly from another object variable of the same class, and both return the name of the object.
\begin{syntax}
\method{var}{=} \$value
\end{syntax}
\begin{syntax}
\method{var}{<-} \$otherVarObj 
\end{syntax}
\begin{args}
\$value & Value to set object variable to. \\
\$otherVarObj & Other object variable to assign value from (must be same class).
\end{args}

The example below demonstrates the myriad of ways object variables can be manipulated:
\begin{example}{Object variable manipulation features}
\begin{lstlisting}
var new x; # Create blank variable $x
[$x --> y] = 5; # Copy $x to $y, and set to 5
[var new z] <- [$x <- $y]; # Create $z and set to x after setting $x to $y.
$z = [expr {[$z] + [$x]}]; # Add $x to $z
append $y [set $x 0]; # Append $y the value of $x after setting $x to 0
puts [list [$x] [$y] [$z]]
\end{lstlisting}
\tcblower
\begin{lstlisting}
0 50 10
\end{lstlisting}
\end{example}

\clearpage

\subsection{Advanced Assignment Operators}
The operator methods ``\texttt{\methodlink[0]{var}{.=}}'', ``\texttt{\methodlink[0]{var}{:=}}'', and ``\texttt{\methodlink[0]{var}{::=}}'' are similar to the operator method ``\texttt{\methodlink[0]{var}{=}}'', except that they can perform a transformation on the existing value of the object variable. 
\begin{syntax}
\method{var}{.=} \$oper
\end{syntax}
\begin{syntax}
\method{var}{:=} \$expr
\end{syntax}
\begin{syntax}
\method{var}{::=} \$body
\end{syntax}
\begin{args}
\$oper & Tcl math operator and additional mathop arguments, i.e. \texttt{"+ 5"}. \\
\$expr & Tcl expression to evaluate. \\
\$body & Tcl script to evaluate.
\end{args}

The operator ``\texttt{\methodlink[0]{var}{.=}}'' passes the value of the object as the first argument in the corresponding Tcl mathop command, allowing for modification in reference to the current value.
Similarly, the operators ``\texttt{\methodlink[0]{var}{:=}}'' and ``\texttt{\methodlink[0]{var}{::=}}'', allow for object self-reference using the command ``\cmdlink{\$.}'', which accesses the global read-only self-reference variable ``\texttt{.}''.
\begin{syntax}
\command{\$.} <\$arg ...>
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

Check out the example below for some examples of how you can use these features to modify variables. 
\begin{example}{Advanced object variable manipulation}
\begin{lstlisting}
var new x 5.0; # Create variable $x
[[var new y] <- $x] .= {+ 10}; # Create new variable y, set to x, and add 10.
set p 2; # Create primative variable
$y := {[$.] ** $p + [$x]}; # Square y, plus $x (230.0) (accesses $p)
$y ::= {split [$.] .}; # Split at decimal (230 0)
$y print
\end{lstlisting}
\tcblower
\begin{lstlisting}
230 0
\end{lstlisting}
\end{example}


\clearpage
\section{Object Variable Types}
The TclOO class \cmdlink{var} acts as a superclass for a pure-Tcl type system. Type classes are created and managed through the command ensemble \cmdlink{type}.
\begin{syntax}
\command{type} \$subcommand \$arg ...
\end{syntax}
\begin{args}
\$subcommand & Subcommand name. \\
\$arg ... & Arguments for subcommand.
\end{args}

New type classes can be created using the subcommands \subcmdlink[0]{type}{new} or \subcmdlink[0]{type}{create}.
Both subcommands create a class that is a subclass of ``\texttt{::vutil::var}'', with a private method \textit{Type} that returns the corresponding type.
If creating a type class with the subcommand \subcmdlink[0]{type}{new}, the resulting class will be named ``\texttt{::vutil::type.\$type}''.
\begin{syntax}
\subcommand{type}{new} \$type \$defScript \\
\subcommand{type}{create} \$type \$name \$defScript
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$name & Name of class. \\
\$defScript & Class definition script. 
\end{args}

To demonstrate how easy it is to create a type class, below is the code used to create the \subcmdlink[0]{new}{string} type.
\begin{example}{Creating a simple type}
\begin{lstlisting}
type new string {
    method info {args} {
        set (length) [my length]
        next {*}$args
    }
    method length {} {
        string length $(value)
    }
    method @ {i} {
        string index $(value) $i
    }
    export @
}
\end{lstlisting}
\end{example}

Note that the value is stored in the blank array name ``value''. 
The blank array is used to store all the object variable properties, and is what is returned with the method ``info''.
By default, from the superclass ``\texttt{::vutil::var}'', there are three properties: (value), (exists), and (type)

\clearpage
\subsection{Type Queries}
A list of all defined types can be queried with the subcommand \subcmdlink[0]{type}{names}. 
\begin{syntax}
\subcommand{type}{names}
\end{syntax}

The existence of a type can be queried with the subcommand \subcmdlink[0]{type}{exists}, and 
the class associated with a type can be queried with the subcommand \subcmdlink[0]{type}{class}. 
\begin{syntax}
\subcommand{type}{exists} \$type
\end{syntax}
\begin{syntax}
\subcommand{type}{class} \$type
\end{syntax}
\begin{args}
\$type & Name of type. 
\end{args}

The subcommand \subcmdlink[0]{type}{isa} checks if an object is of a specific type or of one of its subtypes.
If the type or object does not exist, this command will return an error.
Similarly, the subcommand \subcmdlink[0]{type}{assert} returns an error if an object is not of a specific type or of one its subtypes.

\begin{syntax}
\subcommand{type}{isa} \$type \$object
\end{syntax}
\begin{syntax}
\subcommand{type}{assert} \$type \$object
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$object & Name of object.
\end{args}

\begin{example}{Type assertion}
\begin{lstlisting}
proc foo {bar} {
    type assert list $bar
    $bar @ end
}
\end{lstlisting}
\end{example}

\clearpage
\subsection{Creating Type Variables}
Classes defined by \cmdlink{type} only have the constructor method \textit{new}, so as a convenience, the command \cmdlink{new} creates a new variable object of a specified type. If the reference name provided is blank, it will simply return the value after passing it through the datatype's data validation.

\begin{syntax}
\command{new} \$type \$refName <\$value>
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$refName & Name of reference variable to tie to object. Blank to return value. \\
\$value & Value to set object variable to.
\end{args}

Now you can easily create variables in Tcl with a specified type!
\begin{example}{Creating a new \subcmdlink[0]{new}{string} object variable}
\begin{lstlisting}
new string x
set $x {hello world}
puts [$x length]
puts [$x info]
puts [$x @ end]
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
11
exists 1 length 11 type string value {hello world}
d
hello world
\end{lstlisting}
\end{example}

\clearpage
\section{Type Library}
This package provides a few basic object variable types: \subcmdlink[0]{new}{var}, \subcmdlink[0]{new}{string}, \subcmdlink[0]{new}{bool}, \subcmdlink[0]{new}{int}, \subcmdlink[0]{new}{float}, \subcmdlink[0]{new}{list}, and \subcmdlink[0]{new}{dict}.

\subsection{Type ``var'' (object variable)}
The type ``\subcmdlink[0]{new}{var}'' is just an alternative way to create an object variable (same syntax as ``new'' method for \cmdlink{var} class).
It does not have any additional metadata or methods.
\begin{syntax}
\subcommand{new}{var} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Value to set object variable to.
\end{args}
\subsection{Type ``string''}
The type ``\subcmdlink[0]{new}{string}'' does not do any validation on input (because in Tcl, ``everything is a string''), but additionally provides methods for getting string length and string index, and adds the field ``length'' to the variable info.
\begin{syntax}
\subcommand{new}{string} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & String value.
\end{args}
The method \textit{length} returns the string length. This is the same as ``\texttt{\$stringObj info length}''.
\begin{syntax}
\$stringObj length
\end{syntax}
The method ``\texttt{@}'' returns the character at the specified index.
\begin{syntax}
\$stringObj @ \$i
\end{syntax}
\begin{args}
\$i & String index. 
\end{args}
\clearpage
\subsection{Type ``bool'' (boolean)}
The type ``\subcmdlink[0]{new}{bool}'' validates that the input is a valid boolean, passing input through the Tcl \textit{::tcl::mathfunc::bool} command.
\begin{syntax}
\subcommand{new}{bool} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Boolean value.
\end{args}

In addition to the standard object variable methods, the ``bool'' type provides a shorthand if-statement control flow method:
\begin{syntax}
\$boolObj "?" \$body1 <":" \$body2> 
\end{syntax}
\begin{args}
\$body1 & Body to evaluate if boolean is true. \\
\$body2 & Body to evaluate if boolean is false (optional, required with ``\texttt{:}'' keyword).
\end{args}

\begin{example}{String and boolean example}
\begin{lstlisting}
# proc with types
proc foo {a b c} {
    new string a $a
    new string b $b
    new bool c $c
    $c ? $a : $b
}
puts [foo hello world true]; # hello
puts [foo hello world false]; # world
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello
world
\end{lstlisting}
\end{example}
\clearpage
\subsection{Type ``int'' (integer)}
The type ``\subcmdlink[0]{new}{int}'' validates that the input is a valid integer, and additionally has increment/decrement methods.
\begin{syntax}
\subcommand{new}{int} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Integer value.
\end{args}
In addition to the standard operators, this type also has two short-hand increment/decrement operators, ``\texttt{++}'' and ``\texttt{-{}-}'', which simply increment or decrement the integer object by 1.
\begin{syntax}
\$intObj ++ 
\end{syntax}
\begin{syntax}
\$intObj -{}-
\end{syntax}

\begin{example}{Integer example (for loop)}
\begin{lstlisting}
for {new int i 0} {[$i] < 3} {$i ++} {
    puts [$i]
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
0
1
2
\end{lstlisting}
\end{example}
\clearpage

\subsection{Type ``float'' (double-precision floating-point decimal)}
The type ``\subcmdlink[0]{new}{float}'' validates that input is a double-precision floating-point number, passing input through the Tcl \textit{::tcl::mathfunc::double} command.
\begin{syntax}
\subcommand{new}{float} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Float value.
\end{args}

\begin{example}{Float example (procedure with type assertion)}
\begin{lstlisting}
# Harmonic mean of two numbers (converts to float)
proc hmean {x y} {
    new float x $x
    new float y $y
    [new float z] := {2*[$x]*[$y]}
    if {[$z] != 0} {
        $z := {[$.] / ([$x] + [$y])}
    }
    return [$z]
}
puts [hmean 1 2]; # 1.3333
\end{lstlisting}
\tcblower
\begin{lstlisting}
1.3333333333333333
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``list''}
The type ``\subcmdlink[0]{new}{list}'' validates that the input is a list, adds the field ``length'' to the info dictionary, and additionally passes input from the operators ``\texttt{.=}'', ``\texttt{:=}'', and ``\texttt{::=}'' through the commands \cmdlink{lop}, \cmdlink{lexpr}, and \cmdlink{leval}.
\begin{syntax}
\subcommand{new}{list} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & List value.
\end{args}
The method \methodlink[0]{list}{length} returns the list length. This is the same as ``\texttt{\$listObj info length}''.
\begin{syntax}
\method{list}{length}
\end{syntax}

\begin{example}{List info}
\begin{lstlisting}
new list x {foo bar}
puts [$x info]
\end{lstlisting}
\tcblower
\begin{lstlisting}
exists 1 type list length 2 value {foo bar}
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{List Math Operations}
The command \cmdlink{lop} performs simple math over lists, and is also built-in to the ``\texttt{.=}'' list operator.
\begin{syntax}
\command{lop} \$list \$op <\$arg ...>
\end{syntax}
\begin{args}
\$list & List value to map over. \\
\$op & Tcl math operator. \\
\$arg ... & Additional mathop arguments.
\end{args}
\begin{example}{Element-wise operations}
\begin{lstlisting}
# Primative variable method
set x {1 2 3}
set x [lop $x * 2]
puts $x
# Object variable method
new list x {1 2 3}
$x .= {* 2}
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
2 4 6
2 4 6
\end{lstlisting}
\end{example}
\begin{example}{Nested list operations}
\begin{lstlisting}
# Primative variable method
set x {1 2 3}
set x [lop [lop [lop $x + 1] * 2] - 3]
puts $x
# Object variable method
new list x {1 2 3}
[[$x .= {+ 1}] .= {* 2}] .= {- 3}
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
1 3 5
1 3 5
\end{lstlisting}
\end{example}


\clearpage
\subsubsection{List Reference Mapping}
Using the \cmdlink{::vutil::refsub} syntax, you can create powerful wrapper commands. 
As a demonstration, this package provides two simple list object mapping commands: \cmdlink{leval} and \cmdlink{lexpr}, which are built-in to the ``\texttt{:=}'' and ``\texttt{::=}'' list operators.
\begin{syntax}
\command{leval} \$body <"-{}->" \$refName>
\end{syntax}
\begin{syntax}
\command{lexpr} \$expr <"-{}->" \$refName>
\end{syntax}
\begin{args}
\$body & Tcl script with list object references. \\
\$expr & Tcl expression with list object references. \\
\$refName & Optional reference variable to tie resulting list to. Blank to return value.
\end{args}

\begin{example}{Element-wise expressions}
\begin{lstlisting}
new list x {1 2 3}
new list y {4 5 6}
lexpr {$@x + $@y} --> z
$z := {double($@z)}
$z print
\end{lstlisting}
\tcblower
\begin{lstlisting}
5.0 7.0 9.0
\end{lstlisting}
\end{example}

\begin{example}{Zip a list together (modified from \url{https://www.tcl-lang.org/man/tcl/TclCmd/lmap.htm})}
\begin{lstlisting}
new list list1 {a b c d}
new list list2 {1 2 3 4}
leval {list $@list1 $@list2} --> zipped
$zipped ::= {string toupper $@.}
$zipped print
\end{lstlisting}
\tcblower
\begin{lstlisting}
{A 1} {B 2} {C 3} {D 4}
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{List indexing}
The methods ``\texttt{\methodlink[0]{list}{@}}'' and ``\texttt{\methodlink[0]{list}{@@}}'' either index or modify the list, depending on whether an assignment operator is used. 
If indexing, it calls \textit{lindex} or \textit{lrange}, and returns the corresponding value or range. 
If modifying with an assignment operator, it modifies the list with \textit{lset} or \textit{lreplace} and returns the object name. 
The ``\texttt{=}'' operator simply modifies the list directly.
The other assignment operator create a temporary list variable for the specified index/range and evaluates the assignment operator on the temporary list. 
Then, it modifies the main list with the resulting value of the temporary list, and finally returns the object name. 
\begin{syntax}
\protect\hypertarget{\$listObj @}{\$listObj @}\index{list methods!"@} \$i ... <\$op \$arg>
\end{syntax}
\begin{syntax}
\protect\hypertarget{\$listObj @@}{\$listObj @@}\index{list methods!"@"@} \$first \$last <\$op \$arg>
\end{syntax}
\begin{args}
\$i ... & List indices. \\
\$first & First index in range. \\
\$last & Last index in range. \\
\$op \$arg & Assignment operator (\texttt{= .= := ::=}) and corresponding input. \\
\quad = \$value & Value to set. \\
\quad .= \$oper & Tcl math operator and additional mathop arguments, i.e. \texttt{"+ 5"}. \\
\quad := \$expr & Tcl expression to evaluate. \\
\quad ::= \$body & Tcl script to evaluate.
\end{args}

\begin{example}{List indexing}
\begin{lstlisting}
new list list1 ""
$list1 @ 0 = "hey"
$list1 @ 1 = "there"
$list1 @ end+1 = "world"
set a 5
$list1 @ end+1 := {$a * 2}
$list1 @@ 0 1 ::= {string totitle $@.}
$list1 print
\end{lstlisting}
\tcblower
\begin{lstlisting}
Hey There world 10
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``dict'' (dictionary)}
The type ``\subcmdlink[0]{new}{dict}'' validates that the input is a Tcl dictionary, and provides methods for all the Tcl dictionary subcommands, with the exception of \textit{info}, which due to a conflict with the standard method \textit{info}, was replaced with \methodlink{dict}{stats}. 
Additionally, it adds the field ``size'' to the variable info. 
This package only provides a new, more convenient way to access the Tcl dictionary data structure, which is fully explained and documented here: \url{https://www.tcl.tk/man/tcl/TclCmd/dict.html}.
\begin{syntax}
\subcommand{new}{dict} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Dictionary value.
\end{args}
Below is an example of how the dictionary variable type can streamline basic dictionary queries.
\begin{example}{Dictionary example}
\begin{lstlisting}
# Create dictionary record
new dict record {
    name {John Doe}
    address {
        streetAddress {123 Main Street}
        city {New York}
    }
    phone {555-1234} 
}
# Get values
puts [$record size]; # Number of keys (3)
puts [$record get name]; # John Doe
# Set/unset and get
$record set address street [$record get address streetAddress]
$record unset address streetAddress
puts [$record get address street]; # 123 Main Street
puts [$record exists address streetAddress]; # 0
\end{lstlisting}
\tcblower
\begin{lstlisting}
3
John Doe
123 Main Street
0
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{Dictionary Access Methods}

The method \methodlink[0]{dict}{get} is equivalent to the Tcl command \textit{dict get}. 
It retrieves values from the dictionary at the specified key sequence, and returns an error if entry does not exist.
\begin{syntax}
\method{dict}{get} <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to query. 
\end{args}

The method \methodlink[0]{dict}{exists} is equivalent to the Tcl command \textit{dict exists}.
It returns a boolean value indicating whether a value exists at the specified key sequence. 
\begin{syntax}
\method{dict}{exists} \$key <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to query. 
\end{args}

The method \methodlink[0]{dict}{keys} is equivalent to the Tcl command \textit{dict keys}.
It retrieves a list of the keys stored in the dictionary, with an optional ``glob'' pattern.
\begin{syntax}
\method{dict}{keys} <\$globPattern>
\end{syntax}
\begin{args}
\$globPattern & Optional pattern to match keys with. Default all keys.
\end{args}

The method \methodlink[0]{dict}{values} is equivalent to the Tcl command \textit{dict values}.
It retrieves a list of the values stored in the dictionary, with an optional ``glob'' pattern.
\begin{syntax}
\method{dict}{values} <\$globPattern>
\end{syntax}
\begin{args}
\$globPattern & Optional pattern to match values with. Default all values.
\end{args}

The method \methodlink[0]{dict}{size} is equivalent to the Tcl command \textit{dict size}. This is the same as ``\texttt{\$dictObj info size}''.
It simply returns the number of key-value pairings in the dictionary.
\begin{syntax}
\method{dict}{size}
\end{syntax}

The method \methodlink[0]{dict}{stats} is equivalent to the Tcl command \textit{dict info}. This is the only method that is renamed from the Tcl subcommand counterpart, due to a conflict with the standard object variable method \methodlink[0]{var}{info}.
It simply returns data about the implementation of the dictionary datatype.
\begin{syntax}
\method{dict}{stats}
\end{syntax}
\clearpage
\subsubsection{Dictionary Modification Methods}

The method \methodlink[0]{dict}{set} is equivalent to the Tcl command \textit{dict set}, except that it returns the object name.
It assigns values to the dictionary at the specified key sequence.
\begin{syntax}
\method{dict}{set} \$key <\$key ...> \$value
\end{syntax}
\begin{args}
\$key... & Sequence of keys to set. \\
\$value & Value to set at key sequence.
\end{args}

The method \methodlink[0]{dict}{unset} is equivalent to the Tcl command \textit{dict unset}, except that it returns the object name.
It is the counterpart to \methodlink{dict}{set}, and unsets the dictionary entry at the specified key sequence.
\begin{syntax}
\method{dict}{unset} \$key <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to unset. 
\end{args}

The method \methodlink[0]{dict}{replace} is equivalent to the Tcl command \textit{dict replace}, except that it modifies the object and returns the object name.
It is similar to \methodlink{dict}{set}, except that multiple key-value pairings can be specified (or none).
\begin{syntax}
\method{dict}{replace} <\$key \$value...>
\end{syntax}
\begin{args}
\$key... & Key(s) to replace at. \\
\$value... & Value(s) to replace with. 
\end{args}

The method \methodlink[0]{dict}{remove} is equivalent to the Tcl command \textit{dict remove}, except that it modifies the object and returns the object name.
It is similar to \methodlink{dict}{unset}, except that multiple keys can be specified (or none).
\begin{syntax}
\method{dict}{remove} <\$key ...>
\end{syntax}
\begin{args}
\$key... & Key(s) to remove
\end{args}

The method \methodlink[0]{dict}{merge} is equivalent to the Tcl command \textit{dict merge}, except that it returns the object name.
It merges the entries from multiple dictionaries into the dictionary object variable. 
\begin{syntax}
\method{dict}{merge} <\$dictionaryValue ...>
\end{syntax}
\begin{args}
\$dictionaryValue ... & Dictionary values to merge into object dictionary. 
\end{args}
\clearpage
\subsubsection{Dictionary Entry Manipulation Methods}

The method \methodlink[0]{dict}{append} is equivalent to the Tcl command \textit{dict append}, except that it returns the object name.
It treats the dictionary entry value as a string, and appends to the string. 
\begin{syntax}
\method{dict}{append} \$key <\$string ...>
\end{syntax}
\begin{args}
\$key & Key to append at. \\
\$string ... & Text to append to dictionary entry.
\end{args}

The method \methodlink[0]{dict}{lappend} is equivalent to the Tcl command \textit{dict lappend}, except that it returns the object name.
It treats the dictionary entry value as a list, and appends to the list.
\begin{syntax}
\method{dict}{lappend} \$key <\$value ...>
\end{syntax}
\begin{args}
\$key & Key to lappend at. \\
\$value ... & Values to append to list at specified key.
\end{args}

The method \methodlink[0]{dict}{incr} is equivalent to the Tcl command \textit{dict incr}, except that it returns the object name.
It treats the dictionary entry value as an integer, and increments the value.
\begin{syntax}
\method{dict}{incr} \$key <\$incr>
\end{syntax}
\begin{args}
\$key & Key to increment at. \\
\$incr & Increment value. Default 1.
\end{args}

The method \methodlink[0]{dict}{update} is equivalent to the Tcl command \textit{dict update}.
It allows for modification of dictionary entries directly using a Tcl script.
\begin{syntax}
\method{dict}{update} \$key \$varName <\$key \$varName ...> \$body
\end{syntax}
\begin{args}
\$key... & Keys to update. \\
\$varName... & Variables to store values at specified keys. \\
\$body & Script to evaluate. 
\end{args}
\clearpage
\subsubsection{Dictionary Mapping Methods}

The method \methodlink[0]{dict}{filter} is equivalent to the Tcl command \textit{dict filter}, except that it modifies the object and returns the object name.
It removes entries that do not fit the specified criteria.
\begin{syntax}
\method{dict}{filter} \$filterType \$arg <\$arg ...>
\end{syntax}
\begin{args}
\$filterType & Dictionary filter type. \\
\$arg ... & Additional arguments. See documentation for Tcl command \textit{dict filter}.
\end{args}

The method \methodlink[0]{dict}{for} is equivalent to the Tcl command \textit{dict for}.
It simply loops over the dictionary and evaluates a script.
\begin{syntax}
\method{dict}{for} "\$keyVariable \$valueVariable" \$body
\end{syntax}
\begin{args}
\$keyVariable & Variable to store dictionary key in. \\
\$valueVariable & Variable to store dictionary entry values in. \\
\$body & Tcl script to evaluate for each dictionary entry.
\end{args}

The method \methodlink[0]{dict}{map} is equivalent to the Tcl command \textit{dict map}, except that it modifies the object and returns the object name.
It is equivalent to \methodlink{dict}{for}, except that the result of each iteration gets stored in the dictionary at the corresponding key.
\begin{syntax}
\method{dict}{map} "\$keyVariable \$valueVariable" \$body
\end{syntax}
\begin{args}
\$keyVariable & Variable to store dictionary key in. \\
\$valueVariable & Variable to store dictionary entry values in. \\
\$body & Tcl script to evaluate for each dictionary entry.
\end{args}

The method \methodlink[0]{dict}{with} is equivalent to the Tcl command \textit{dict with}. 
It sets variables with names equal to the dictionary key names, and evaluates a script. 
Note that this should not be used if the dictionary key names conflict with the object variable name.
\begin{syntax}
\method{dict}{with} <\$key ...> \$body
\end{syntax}
\begin{args}
\$key... & Sequence of keys containing the dictionary to use. \\
\$body & Tcl script to evaluate with entries as variables.
\end{args}


\clearpage
{\small\printindex}
\end{document}
































