\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}

% Other macros

\title{\Huge Tcl Variable Utilities\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/vutil}}
\date{\small\today}
\makeindex[columns=3,title={Command Index}]
\begin{document}
\maketitle
\begin{abstract}
\begin{center}
This package provides various utilities for working with variables in Tcl, including read-only variables, TclOO garbage collection, and an object-variable type system.
\end{center}
\end{abstract}

\clearpage
\section{Default Values}
The command \cmdlink{default} assigns values to variables if they do not exist.
\begin{syntax}
\command{default} \$varName \$value
\end{syntax}
\begin{args}
\$varName & Name of variable to set \\
\$value & Default value for variable
\end{args}

The example below shows how default values are only applied if the variable does not exist.
\begin{example}{Variable defaults}
\begin{lstlisting}
set a 5
default a 7; # equivalent to "if {![info exists a]} {set a 7}"
puts $a
unset a
default a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
7
\end{lstlisting}
\end{example}
\clearpage
\section{Variable Locks}
The command \cmdlink{lock} uses Tcl variable traces to make a read-only variable. 
If attempting to modify a locked variable, it will throw a warning, but not an error.

\begin{syntax}
\command{lock} \$varName <\$value>
\end{syntax}
\begin{args}
\$varName & Variable name to lock.  \\
\$value & Value to lock variable at. Default self-locks (uses current value).
\end{args}

The command \cmdlink{unlock} unlocks previously locked variables so that they can be modified again.
\begin{syntax}
\command{unlock} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to unlock.
\end{args}

\begin{example}{Variable locks}
\begin{lstlisting}
lock a 5
set a 7; # throws warning to stderr channel
puts $a
unlock a
set a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
failed to modify "a": read-only
5
7
\end{lstlisting}
\end{example}

Note: You can lock array elements, but not an entire array.

\clearpage

\section{Variable-Object Ties}
As of Tcl version 8.6, there is no garbage collection for Tcl objects, they have to be removed manually with the ``destroy'' method. 
The command \cmdlink{tie} is a solution for this problem, using variable traces to destroy the corresponding object when the variable is unset or modified. 
For example, if an object is tied to a local procedure variable, the object will be destroyed when the procedure returns.


\begin{syntax}
\command{tie} \$refName <\$object>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$object & Object to tie variable to. Default self-ties (uses current value).
\end{args}

In similar fashion to \cmdlink{unlock}, tied variables can be untied with the command \cmdlink{untie}.
\begin{syntax}
\command{untie} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to untie.
\end{args}

\begin{example}{Variable-object ties}
\begin{lstlisting}
oo::class create foo {
    method hi {} {
        puts hi
    }
}
tie a [foo create bar]
set b $a; # alias variable
unset a; # triggers ``destroy''
$b hi; # throws error
\end{lstlisting}
\tcblower
\begin{lstlisting}
invalid command name "::bar"
\end{lstlisting}
\end{example}

Note: You can tie array elements, but not an entire array, and you cannot tie a locked variable.
\clearpage
\subsection{Reference Variables}
Valid reference variables for the \cmdlink{tie} command must match the following regular expression:
\begin{lstlisting}
(::+|\w+)+(\(\w+\))?
\end{lstlisting}
The one exception to this rule is the shared global reference variable ``\textbf{\texttt{\&}}''.
This shared reference, regardless of scope, can be accessed with the command ``\textbf{\texttt{\cmdlink{\$\&}}}''.
\begin{syntax}
\command{\$\&} \$arg ...
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

\subsubsection{Reference Parser API}
The command \cmdlink{::vutil::RefSub}, which performs ``\texttt{\$@ref}'' substitution on a given string, returning the updated string and all matched reference names. 
For example, ``\texttt{\$@ref}'' is converted to ``\texttt{\$\{::@(ref)\}}'': an element of the global array variable ``\texttt{@}''.
To escape a reference, especially for nested substitution, simply add more ``\texttt{@}'' symbols, like ``\texttt{\$@@ref}''.
This command is not exported, as it is intended for use by developers.
\begin{syntax}
\command{::vutil::RefSub} \$string
\end{syntax}
\begin{args}
\$string & String to perform substitution with.
\end{args}

There are two special references: ``\texttt{\$@\&}'' and ``\texttt{\$@.}''. Both refer to the global variables ``\texttt{\&}'' and ``\texttt{.}'', respectively, and they are always listed first in the reference variable list, as shown in the example below:
\begin{example}{Reference variable substitution}
\begin{lstlisting}
lassign [::vutil::RefSub {$@& + $@x(1) - $@@y + $@.}] string refs
puts $string
puts $refs
\end{lstlisting}
\tcblower
\begin{lstlisting}
${::@(::&)} + ${::@(x(1))} - $@y + ${::@(::.)}
::& ::. x(1)
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{Garbage Collection Superclass}
The class ``\texttt{\command{::vutil::GC}}'' is a TclOO superclass that includes garbage collection. 
This class is not exported, and not intended for direct use, as it is simply a template for classes with built-in garbage collection, by tying the object to a specified reference variable using \cmdlink{tie}.
In addition to tying the object to a reference variable in the superclass constructor, the ``\texttt{::vutil::GC}'' superclass also provides a method for copying the object to a new reference variable: ``\texttt{-{}->}''.
\begin{syntax}
\$obj -{}-> \$refName
\end{syntax}
\begin{args}
\$obj & Object that inherits the ``\texttt{::vutil::GC}'' superclass. \\
\$refName & Name of reference variable for garbage collection.
\end{args}

Below is an example of how this superclass can be used to build garbage collection into a TclOO class. 
\begin{example}{Creating a class with garbage collection}
\begin{lstlisting}
oo::class create container {
    superclass ::vutil::GC
    variable myValue
    constructor {refName value} {
        set myValue $value
        next $refName
    }
    method set {value} {set myValue $value}
    method value {} {return $myValue}
}
proc wrap {value} {
    container new & $value
    return $&
}
[wrap {hello world}] --> x
puts [$x value]
unset x; # also destroys object
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
\end{lstlisting}
\end{example}
\clearpage
\section{Object Variable Class}
The TclOO class \cmdlink{var} is a subclass of ``\texttt{::vutil::GC}'' that acts as a container class for data, so that calling the object variable by itself (e.g. \texttt{[\$varObj]}) returns the value stored in the object.
\begin{syntax}
\command{var} new \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$value & Value to set object variable to. Default blank.
\end{args}

\subsection{Standard Object Variable Operators}
The operator method ``\texttt{\methodlink[0]{var}{=}}'' assigns the value of the object variable, returning the name of the object.
The operator method ``\texttt{\methodlink[0]{var}{<-}}'' assigns the value and any object metadata directly from another object variable of the same class, returning the name of the object.
The operator method ``\texttt{\methodlink[0]{var}{-{}->}}'' copies the object variable to a new reference variable, returning the name of the new object.
\begin{syntax}
\method{var}{=} \$value
\end{syntax}
\begin{syntax}
\method{var}{<-} \$otherVarObj 
\end{syntax}
\begin{syntax}
\method{var}{-{}->} \$refName
\end{syntax}
\begin{args}
\$value & Value to set object variable to. \\
\$otherVarObj & Other object variable to assign value from (must be same class). \\
\$refName & Name of reference variable for garbage collection.
\end{args}

The example below demonstrates the myriad of ways object variables can be manipulated:
\begin{example}{Standard object variable operators}
\begin{lstlisting}
var new x; # Create blank object variable $x
[$x --> y] = 2; # Copy $x to $y, and set to 2
[var new z] <- [$x <- $y]; # Create $z and set to $x after setting $x to $y.
puts [list [$x] [$y] [$z]]
\end{lstlisting}
\tcblower
\begin{lstlisting}
2 2 2
\end{lstlisting}
\end{example}


\clearpage
\subsection{Advanced Object Variable Operators}
The operator methods ``\texttt{\methodlink[0]{var}{.=}}'', ``\texttt{\methodlink[0]{var}{:=}}'', and ``\texttt{\methodlink[0]{var}{::=}}'' are similar to the operator method ``\texttt{\methodlink[0]{var}{=}}'', except that they can perform a transformation on the existing value of the object variable. 
\begin{syntax}
\method{var}{.=} \$oper
\end{syntax}
\begin{syntax}
\method{var}{:=} \$expr
\end{syntax}
\begin{syntax}
\method{var}{::=} \$body
\end{syntax}
\begin{args}
\$oper & Tcl math operator and additional mathop arguments, i.e. \texttt{"+ 5"}. \\
\$expr & Tcl expression to evaluate, passing input through the Tcl \textit{expr} command. \\
\$body & Tcl script to evaluate.
\end{args}

The operator ``\texttt{\methodlink[0]{var}{.=}}'' passes the value of the object as the first argument in the corresponding Tcl mathop command, allowing for modification in reference to the current value.
Similarly, the operators ``\texttt{\methodlink[0]{var}{:=}}'' and ``\texttt{\methodlink[0]{var}{::=}}'', allow for object self-reference using the command ``\cmdlink{\$.}'', which accesses the global read-only self-reference variable ``\texttt{.}''.
\begin{syntax}
\command{\$.} <\$arg ...>
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

The example below demonstrates how you can use these features to manipulate object variables.
\begin{example}{Advanced object variable operators}
\begin{lstlisting}
var new x 5.0; # Create variable $x
[[var new y] <- $x] .= {+ 10}; # Create new variable y, set to x, and add 10.
set p 2; # Create primative variable
$y := {[$.] ** $p + [$x]}; # Square y, plus $x (230.0) (accesses $p)
$y ::= {split [$.] .}; # Split at decimal (230 0)
puts [$y]
\end{lstlisting}
\tcblower
\begin{lstlisting}
230 0
\end{lstlisting}
\end{example}

\clearpage
\subsection{Object Variable Metadata}
The method \methodlink[0]{var}{info} accesses all object variable metadata. 
Fields ``type'' and ``value'' are standard.
\begin{syntax}
\method{var}{info} <\$field>
\end{syntax}
\begin{args}
\$field & Info field to get. Default returns dictionary of all info. \\
\end{args}

\subsection{Printing an Object Variable Value}
The method \methodlink[0]{var}{print} prints the value of the variable to screen or file.
\begin{syntax}
\method{var}{print} <-nonewline> <\$channelID>
\end{syntax}
\begin{args}
-nonewline & Option to print without newline. \\
\$channelID & Channel ID open for writing. Default stdout.
\end{args}

\subsection{Destroying an Object Variable}
Because object variables are simply TclOO objects, they can be destroyed with the standard method \methodlink[0]{var}{destroy}. 
Additionally, unsetting the linked variable will also destroy the object.
\begin{syntax}
\method{var}{destroy} \\
unset \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable used for garbage collection.
\end{args}

\begin{example}{Standard object variable methods}
\begin{lstlisting}
var new x {Hello World}
puts [$x info]
$x print
$x destroy; # or "unset x"
\end{lstlisting}
\tcblower
\begin{lstlisting}
type var value {Hello World}
Hello World
\end{lstlisting}
\end{example}

\clearpage
\section{Object Variable Types}
The TclOO class \cmdlink{var} acts as a superclass for a pure-Tcl type system. Type classes are created and managed through the command ensemble \cmdlink{type}.
\begin{syntax}
\command{type} \$subcommand \$arg ...
\end{syntax}
\begin{args}
\$subcommand & Subcommand name. \\
\$arg ... & Arguments for subcommand.
\end{args}

New type classes can be created using the subcommands \subcmdlink[0]{type}{new} or \subcmdlink[0]{type}{create}.
Both subcommands create a class that is a subclass of ``\texttt{::vutil::var}'', with a private method \textit{Type} that returns the corresponding type.
If creating a type class with the subcommand \subcmdlink[0]{type}{new}, the resulting class will be named ``\texttt{::vutil::type.\$type}''.
\begin{syntax}
\subcommand{type}{new} \$type \$defScript \\
\subcommand{type}{create} \$type \$name \$defScript
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$name & Name of class. \\
\$defScript & Class definition script. 
\end{args}

Note: The value of the object variable is stored in the blank array name ``value''. 
The blank array is used to store all the object variable properties, and is what is returned with the method ``info''.
By default, from the superclass ``\texttt{::vutil::var}'', there are two properties: (value) and (type).

\clearpage
\subsection{Type Queries}
A list of all defined types can be queried with the subcommand \subcmdlink[0]{type}{names}. 
\begin{syntax}
\subcommand{type}{names}
\end{syntax}

The existence of a type can be queried with the subcommand \subcmdlink[0]{type}{exists}, and 
the class associated with a type can be queried with the subcommand \subcmdlink[0]{type}{class}. 
\begin{syntax}
\subcommand{type}{exists} \$type
\end{syntax}
\begin{syntax}
\subcommand{type}{class} \$type
\end{syntax}
\begin{args}
\$type & Name of type. 
\end{args}

The subcommand \subcmdlink[0]{type}{isa} checks if an object is of a specific type or of one of its subtypes.
If the type or object does not exist, this command will return an error.
Similarly, the subcommand \subcmdlink[0]{type}{assert} returns an error if an object is not of a specific type or of one its subtypes.

\begin{syntax}
\subcommand{type}{isa} \$type \$object
\end{syntax}
\begin{syntax}
\subcommand{type}{assert} \$type \$object
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$object & Name of object.
\end{args}

\clearpage
\section{Basic Type Library}
This package provides a few basic object variable types: \subcmdlink[0]{new}{var}, \subcmdlink[0]{new}{string}, \subcmdlink[0]{new}{bool}, \subcmdlink[0]{new}{int} and  \subcmdlink[0]{new}{float}.

\subsection{Creating Type Variables}
Classes defined by \cmdlink{type} only have the constructor method \textit{new}, so as a convenience, the command \cmdlink{new} creates a new variable object of a specified type. If the reference name provided is blank, it will simply return the value after passing it through the datatype's data validation.

\begin{syntax}
\command{new} \$type \$refName <\$value>
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$refName & Name of reference variable to tie to object. Blank to return value. \\
\$value & Value to set object variable to (default varies).
\end{args}

\subsection{Type ``var'' (object variable)}
The type ``\subcmdlink[0]{new}{var}'' is just an alternative way to create an object variable (same syntax as ``new'' method for \cmdlink{var} class).
It is the superclass for all other types.
\begin{syntax}
\subcommand{new}{var} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Value to set object variable to (default blank).
\end{args}
\begin{example}{Basic object variable}
\begin{lstlisting}
new var a
puts [$a info]
[$a = foobar] print
\end{lstlisting}
\tcblower
\begin{lstlisting}
type var value {}
foobar
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``string''}
The type ``\subcmdlink[0]{new}{string}'' does not do any validation on input (because in Tcl, ``everything is a string''), adds the field ``length'' to the object info, and provides convenient methods for string processing.
\begin{syntax}
\subcommand{new}{string} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & String value (default blank).
\end{args}
The method \methodlink[0]{string}{length} returns the string length. This is the same as ``\texttt{\$stringObj info length}''.
\begin{syntax}
\method{string}{length}
\end{syntax}
The method \methodlink[0]{string}{append} simply appends values to the string.
\begin{syntax}
\method{string}{append} \$value ...
\end{syntax}
\begin{args}
\$value ... & String values to append.
\end{args}
The method ``\texttt{\methodlink[0]{string}{@}}'' can be used for string indexing and modification. 
If indexing, it will return the value, and if modifying, it will return the object.
\begin{syntax}
\protect\hypertarget{\$stringObj @}{\$stringObj @}\index{string methods!"@} \$first <\$last> <= \$newstring>
\end{syntax}
\begin{args}
\$first & First index in range. \\
\$last & Last index in range (default \texttt{\$first}). \\
\$newstring & Value to replace with. Default just returns the string index/range.
\end{args}

\begin{example}{String type example}
\begin{lstlisting}
new string x hello
$x append { world}
puts [$x length]
[$x @ 0 = H] print
\end{lstlisting}
\tcblower
\begin{lstlisting}
11
Hello world
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``bool'' (boolean)}
The type ``\subcmdlink[0]{new}{bool}'' validates input by passing it through the Tcl \textit{::tcl::mathfunc::bool} command, which ensures that the input is a valid boolean (0 or 1).
\begin{syntax}
\subcommand{new}{bool} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Boolean value (default 0).
\end{args}
The method  ``\texttt{\methodlink[0]{bool}{?}}'' provides a shorthand if-statement control flow method.
\begin{syntax}
\method{bool}{?} \$body1 <":" \$body2> 
\end{syntax}
\begin{args}
\$body1 & Body to evaluate if boolean is true. \\
\$body2 & Body to evaluate if boolean is false (optional, required with ``\texttt{:}'' keyword).
\end{args}

\begin{example}{Boolean type example}
\begin{lstlisting}
# Procedure with type validation
proc foo {a b c} {
    new string a $a
    new string b $b
    new bool c $c
    $c ? $a : $b
}
puts [foo hello world true]; # hello
puts [foo hello world false]; # world
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello
world
\end{lstlisting}
\end{example}
\clearpage
\subsection{Type ``int'' (integer)}
The type ``\subcmdlink[0]{new}{int}'' validates that the input is a valid integer, and additionally has increment/decrement methods.
\begin{syntax}
\subcommand{new}{int} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Integer value (default 0).
\end{args}
The methods ``\texttt{\methodlink[0]{int}{++}}'' and ``\texttt{\methodlink[0]{int}{-{}-}}'', simply increment/decrement the integer object by 1, and return the object.
\begin{syntax}
\method{int}{++} 
\end{syntax}
\begin{syntax}
\method{int}{-{}-} 
\end{syntax}
The methods ``\texttt{\methodlink[0]{int}{+=}}'', ``\texttt{\methodlink[0]{int}{-=}}'', ``\texttt{\methodlink[0]{int}{*=}}'' and ``\texttt{\methodlink[0]{v}{/=}}'' add, subtract, multiply, and perform integer division on the current value of the object variable.
Like the \texttt{\methodlink[0]{var}{:=}} method, it returns the object name.
\begin{syntax}
\method{int}{+=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{-=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{*=} \$expr
\end{syntax}
\begin{syntax}
\method{int}{/=} \$expr
\end{syntax}
\begin{args}
\$expr & Expression to evaluate (passes through the ``\texttt{\methodlink[0]{var}{:=}}'' method).
\end{args}

\begin{example}{Integer example}
\begin{lstlisting}
for {new int i} {[$i] < 4} {$i ++} {
    $i print
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
0
1
2
3
\end{lstlisting}
\end{example}
\clearpage

\subsection{Type ``float'' (double-precision floating-point decimal)}
The type ``\subcmdlink[0]{new}{float}'' validates that input is a double-precision floating-point number, passing input through the Tcl \textit{::tcl::mathfunc::double} command.
\begin{syntax}
\subcommand{new}{float} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Float value (default 0.0).
\end{args}
The methods ``\texttt{\methodlink[0]{float}{+=}}'', ``\texttt{\methodlink[0]{float}{-=}}'', ``\texttt{\methodlink[0]{float}{*=}}'' and ``\texttt{\methodlink[0]{float}{/=}}'' add, subtract, multiply, and perform division on the current value of the object variable.
Like the \texttt{\methodlink[0]{var}{:=}} method, it returns the object name.
\begin{syntax}
\method{float}{+=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{-=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{*=} \$expr
\end{syntax}
\begin{syntax}
\method{float}{/=} \$expr
\end{syntax}
\begin{args}
\$expr & Expression to evaluate (passes through ``\texttt{\methodlink[0]{var}{:=}}'' method).
\end{args}

\begin{example}{Float example}
\begin{lstlisting}
# Harmonic mean of two numbers (converts to float)
proc hmean {x y} {
    new float x $x
    new float y $y
    [new float z] := {2*[$x]*[$y]}
    if {[$z] != 0} {
        $z /= {[$x] + [$y]}
    }
    return [$z]
}
puts [hmean 1 2]; # 1.3333
\end{lstlisting}
\tcblower
\begin{lstlisting}
1.3333333333333333
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``list''}
The type ``\subcmdlink[0]{new}{list}'' validates that the input is a list, adds the field ``length'' to the info dictionary, and additionally passes input from the operators ``\texttt{.=}'', ``\texttt{:=}'', and ``\texttt{::=}'' through the commands \cmdlink{lop}, \cmdlink{lexpr}, and \cmdlink{leval}.
This variable type does not validate the values stored in the list, just that it is a valid list.
\begin{syntax}
\subcommand{new}{list} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & List value (default blank).
\end{args}
The method \methodlink[0]{list}{length} returns the list length. This is the same as ``\texttt{\$listObj info length}''.
\begin{syntax}
\method{list}{length}
\end{syntax}
The method \methodlink[0]{string}{append} simply appends values to the list.
\begin{syntax}
\method{list}{append} \$value ...
\end{syntax}
\begin{args}
\$value ... & String values to append.
\end{args}
\begin{example}{List example}
\begin{lstlisting}
new list x foo
$x append bar
puts [$x info]
\end{lstlisting}
\tcblower
\begin{lstlisting}
type list length 2 value {foo bar}
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{List Math Operations}
The command \cmdlink{lop} performs simple math over lists, and is also built-in to the ``\texttt{.=}'' list operator.
\begin{syntax}
\command{lop} \$list \$op <\$arg ...>
\end{syntax}
\begin{args}
\$list & List value to map over. \\
\$op & Tcl math operator. \\
\$arg ... & Additional mathop arguments.
\end{args}
\begin{example}{Element-wise operations}
\begin{lstlisting}
# Primative variable method
set x {1 2 3}
set x [lop $x * 2]
puts $x
# Object variable method
new list x {1 2 3}
$x .= {* 2}
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
2 4 6
2 4 6
\end{lstlisting}
\end{example}
\begin{example}{Nested list operations}
\begin{lstlisting}
# Primative variable method
set x {1 2 3}
set x [lop [lop [lop $x + 1] * 2] - 3]
puts $x
# Object variable method
new list x {1 2 3}
[[$x .= {+ 1}] .= {* 2}] .= {- 3}
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
1 3 5
1 3 5
\end{lstlisting}
\end{example}


\clearpage
\subsubsection{List Reference Mapping}
Using the \cmdlink{::vutil::RefSub} syntax, you can create powerful wrapper commands. 
As a demonstration, this package provides two simple list object mapping commands: \cmdlink{leval} and \cmdlink{lexpr}, which are built-in to the ``\texttt{:=}'' and ``\texttt{::=}'' list operators.
\begin{syntax}
\command{leval} \$body <"-{}->" \$refName>
\end{syntax}
\begin{syntax}
\command{lexpr} \$expr <"-{}->" \$refName>
\end{syntax}
\begin{args}
\$body & Tcl script with list object references. \\
\$expr & Tcl expression with list object references. \\
\$refName & Optional reference variable to tie resulting list to. Blank to return value.
\end{args}

\begin{example}{Element-wise expressions}
\begin{lstlisting}
new list x {1 2 3}
new list y {4 5 6}
lexpr {$@x + $@y} --> z
$z := {double($@z)}
$z print
\end{lstlisting}
\tcblower
\begin{lstlisting}
5.0 7.0 9.0
\end{lstlisting}
\end{example}

\begin{example}{Zip a list together}
\begin{lstlisting}
new list list1 {a b c d}
new list list2 {1 2 3 4}
leval {list $@list1 $@list2} --> zipped
$zipped ::= {string toupper $@.}
$zipped print
\end{lstlisting}
\tcblower
\begin{lstlisting}
{A 1} {B 2} {C 3} {D 4}
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{List indexing}
The methods ``\texttt{\methodlink[0]{list}{@}}'' and ``\texttt{\methodlink[0]{list}{@@}}'' either index or modify the list, depending on whether an assignment operator is used. 
If indexing, it calls \textit{lindex} or \textit{lrange}, and returns the corresponding value or range. 
If modifying with an assignment operator, it modifies the list with \textit{lset} or \textit{lreplace} and returns the object name. 
The ``\texttt{=}'' operator simply modifies the list directly.
The other assignment operator create a temporary list variable for the specified index/range and evaluates the assignment operator on the temporary list. 
Then, it modifies the main list with the resulting value of the temporary list, and finally returns the object name. 
\begin{syntax}
\protect\hypertarget{\$listObj @}{\$listObj @}\index{list methods!"@} \$i ... <\$op \$arg>
\end{syntax}
\begin{syntax}
\protect\hypertarget{\$listObj @@}{\$listObj @@}\index{list methods!"@"@} \$first \$last <\$op \$arg>
\end{syntax}
\begin{args}
\$i ... & List indices. \\
\$first & First index in range. \\
\$last & Last index in range. \\
\$op \$arg & Assignment operator (\texttt{= .= := ::=}) and corresponding input. \\
\quad = \$value & Value to set. \\
\quad .= \$oper & Tcl math operator and additional mathop arguments, i.e. \texttt{"+ 5"}. \\
\quad := \$expr & Tcl expression to evaluate. \\
\quad ::= \$body & Tcl script to evaluate.
\end{args}

\begin{example}{List indexing}
\begin{lstlisting}
new list list1 ""
$list1 @ 0 = "hey"
$list1 @ 1 = "there"
$list1 @ end+1 = "world"
set a 5
$list1 @ end+1 := {$a * 2}
$list1 @@ 0 1 ::= {string totitle $@.}
$list1 print
\end{lstlisting}
\tcblower
\begin{lstlisting}
Hey There world 10
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``dict'' (dictionary)}
The type ``\subcmdlink[0]{new}{dict}'' validates that the input is a Tcl dictionary, and provides methods for all the Tcl dictionary subcommands, with the exception of \textit{info}, which due to a conflict with the standard method \textit{info}, was replaced with \methodlink{dict}{stats}. 
Additionally, it adds the field ``size'' to the variable info. 
This package only provides a new, more convenient way to access the Tcl dictionary data structure, which is fully explained and documented here: \url{https://www.tcl.tk/man/tcl/TclCmd/dict.html}.
\begin{syntax}
\subcommand{new}{dict} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Dictionary value (default blank).
\end{args}
Below is an example of how the dictionary variable type can streamline basic dictionary queries.
\begin{example}{Dictionary example}
\begin{lstlisting}
# Create dictionary record
new dict record {
    name {John Doe}
    address {
        streetAddress {123 Main Street}
        city {New York}
    }
    phone {555-1234} 
}
# Get values
puts [$record size]; # Number of keys (3)
puts [$record get name]; # John Doe
# Set/unset and get
$record set address street [$record get address streetAddress]
$record unset address streetAddress
puts [$record get address street]; # 123 Main Street
puts [$record exists address streetAddress]; # 0
\end{lstlisting}
\tcblower
\begin{lstlisting}
3
John Doe
123 Main Street
0
\end{lstlisting}
\end{example}

\clearpage
\subsubsection{Dictionary Access Methods}

The method \methodlink[0]{dict}{get} is equivalent to the Tcl command \textit{dict get}. 
It retrieves values from the dictionary at the specified key sequence, and returns an error if entry does not exist.
\begin{syntax}
\method{dict}{get} <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to query. 
\end{args}

The method \methodlink[0]{dict}{exists} is equivalent to the Tcl command \textit{dict exists}.
It returns a boolean value indicating whether a value exists at the specified key sequence. 
\begin{syntax}
\method{dict}{exists} \$key <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to query. 
\end{args}

The method \methodlink[0]{dict}{keys} is equivalent to the Tcl command \textit{dict keys}.
It retrieves a list of the keys stored in the dictionary, with an optional ``glob'' pattern.
\begin{syntax}
\method{dict}{keys} <\$globPattern>
\end{syntax}
\begin{args}
\$globPattern & Optional pattern to match keys with. Default all keys.
\end{args}

The method \methodlink[0]{dict}{values} is equivalent to the Tcl command \textit{dict values}.
It retrieves a list of the values stored in the dictionary, with an optional ``glob'' pattern.
\begin{syntax}
\method{dict}{values} <\$globPattern>
\end{syntax}
\begin{args}
\$globPattern & Optional pattern to match values with. Default all values.
\end{args}

The method \methodlink[0]{dict}{size} is equivalent to the Tcl command \textit{dict size}. This is the same as ``\texttt{\$dictObj info size}''.
It simply returns the number of key-value pairings in the dictionary.
\begin{syntax}
\method{dict}{size}
\end{syntax}

The method \methodlink[0]{dict}{stats} is equivalent to the Tcl command \textit{dict info}. This is the only method that is renamed from the Tcl subcommand counterpart, due to a conflict with the standard object variable method \methodlink[0]{var}{info}.
It simply returns data about the implementation of the dictionary datatype.
\begin{syntax}
\method{dict}{stats}
\end{syntax}
\clearpage
\subsubsection{Dictionary Modification Methods}

The method \methodlink[0]{dict}{set} is equivalent to the Tcl command \textit{dict set}, except that it returns the object name.
It assigns values to the dictionary at the specified key sequence.
\begin{syntax}
\method{dict}{set} \$key <\$key ...> \$value
\end{syntax}
\begin{args}
\$key... & Sequence of keys to set. \\
\$value & Value to set at key sequence.
\end{args}

The method \methodlink[0]{dict}{unset} is equivalent to the Tcl command \textit{dict unset}, except that it returns the object name.
It is the counterpart to \methodlink{dict}{set}, and unsets the dictionary entry at the specified key sequence.
\begin{syntax}
\method{dict}{unset} \$key <\$key ...>
\end{syntax}
\begin{args}
\$key... & Sequence of keys to unset. 
\end{args}

The method \methodlink[0]{dict}{replace} is equivalent to the Tcl command \textit{dict replace}, except that it modifies the object and returns the object name.
It is similar to \methodlink{dict}{set}, except that multiple key-value pairings can be specified (or none).
\begin{syntax}
\method{dict}{replace} <\$key \$value...>
\end{syntax}
\begin{args}
\$key... & Key(s) to replace at. \\
\$value... & Value(s) to replace with. 
\end{args}

The method \methodlink[0]{dict}{remove} is equivalent to the Tcl command \textit{dict remove}, except that it modifies the object and returns the object name.
It is similar to \methodlink{dict}{unset}, except that multiple keys can be specified (or none).
\begin{syntax}
\method{dict}{remove} <\$key ...>
\end{syntax}
\begin{args}
\$key... & Key(s) to remove
\end{args}

The method \methodlink[0]{dict}{merge} is equivalent to the Tcl command \textit{dict merge}, except that it returns the object name.
It merges the entries from multiple dictionaries into the dictionary object variable. 
\begin{syntax}
\method{dict}{merge} <\$dictionaryValue ...>
\end{syntax}
\begin{args}
\$dictionaryValue ... & Dictionary values to merge into object dictionary. 
\end{args}
\clearpage
\subsubsection{Dictionary Entry Manipulation Methods}

The method \methodlink[0]{dict}{append} is equivalent to the Tcl command \textit{dict append}, except that it returns the object name.
It treats the dictionary entry value as a string, and appends to the string. 
\begin{syntax}
\method{dict}{append} \$key <\$string ...>
\end{syntax}
\begin{args}
\$key & Key to append at. \\
\$string ... & Text to append to dictionary entry.
\end{args}

The method \methodlink[0]{dict}{lappend} is equivalent to the Tcl command \textit{dict lappend}, except that it returns the object name.
It treats the dictionary entry value as a list, and appends to the list.
\begin{syntax}
\method{dict}{lappend} \$key <\$value ...>
\end{syntax}
\begin{args}
\$key & Key to lappend at. \\
\$value ... & Values to append to list at specified key.
\end{args}

The method \methodlink[0]{dict}{incr} is equivalent to the Tcl command \textit{dict incr}, except that it returns the object name.
It treats the dictionary entry value as an integer, and increments the value.
\begin{syntax}
\method{dict}{incr} \$key <\$incr>
\end{syntax}
\begin{args}
\$key & Key to increment at. \\
\$incr & Increment value. Default 1.
\end{args}

The method \methodlink[0]{dict}{update} is equivalent to the Tcl command \textit{dict update}.
It allows for modification of dictionary entries directly using a Tcl script.
\begin{syntax}
\method{dict}{update} \$key \$varName <\$key \$varName ...> \$body
\end{syntax}
\begin{args}
\$key... & Keys to update. \\
\$varName... & Variables to store values at specified keys. \\
\$body & Script to evaluate. 
\end{args}
\clearpage
\subsubsection{Dictionary Mapping Methods}

The method \methodlink[0]{dict}{filter} is equivalent to the Tcl command \textit{dict filter}, except that it modifies the object and returns the object name.
It removes entries that do not fit the specified criteria.
\begin{syntax}
\method{dict}{filter} \$filterType \$arg <\$arg ...>
\end{syntax}
\begin{args}
\$filterType & Dictionary filter type. \\
\$arg ... & Additional arguments. See documentation for Tcl command \textit{dict filter}.
\end{args}

The method \methodlink[0]{dict}{for} is equivalent to the Tcl command \textit{dict for}.
It simply loops over the dictionary and evaluates a script.
\begin{syntax}
\method{dict}{for} "\$keyVariable \$valueVariable" \$body
\end{syntax}
\begin{args}
\$keyVariable & Variable to store dictionary key in. \\
\$valueVariable & Variable to store dictionary entry values in. \\
\$body & Tcl script to evaluate for each dictionary entry.
\end{args}

The method \methodlink[0]{dict}{map} is equivalent to the Tcl command \textit{dict map}, except that it modifies the object and returns the object name.
It is equivalent to \methodlink{dict}{for}, except that the result of each iteration gets stored in the dictionary at the corresponding key.
\begin{syntax}
\method{dict}{map} "\$keyVariable \$valueVariable" \$body
\end{syntax}
\begin{args}
\$keyVariable & Variable to store dictionary key in. \\
\$valueVariable & Variable to store dictionary entry values in. \\
\$body & Tcl script to evaluate for each dictionary entry.
\end{args}

The method \methodlink[0]{dict}{with} is equivalent to the Tcl command \textit{dict with}. 
It sets variables with names equal to the dictionary key names, and evaluates a script. 
Note that this should not be used if the dictionary key names conflict with the object variable name.
\begin{syntax}
\method{dict}{with} <\$key ...> \$body
\end{syntax}
\begin{args}
\$key... & Sequence of keys containing the dictionary to use. \\
\$body & Tcl script to evaluate with entries as variables.
\end{args}


\clearpage
\printindex
\end{document}
































