\documentclass{article}

% Input packages & formatting
\input{template/packages}
\input{template/formatting}
\input{template/version}
\renewcommand{\cleartooddpage}[1][]{\ignorespaces} % single side
\newcommand{\caret}{$^\wedge$}

% Other macros

\title{\Huge Tcl Variable Utilities\\\small Version \version}
\author{Alex Baker\\\small\url{https://github.com/ambaker1/vutil}}
\date{\small\today}
\makeindex[columns=2,title={Command Index}]
\begin{document}
\maketitle
\begin{abstract}
\begin{center}
This package provides various utilities for working with variables in Tcl, including read-only variables, TclOO garbage collection, and an object-variable type system.
\end{center}
\end{abstract}
\clearpage
\section{Initializing Local Namespace Variables}
The command \cmdlink{local} is the counterpart to the Tcl \textit{global} command, and creates local variables linked to variables in the current namespace, by simply calling the Tcl \textit{variable} command multiple times.
\begin{syntax}
\command{local} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Name(s) of variables to initialize
\end{args}
\begin{example}{Access namespace variables in a procedure}
\begin{lstlisting}
# Define global variables
global a b c
set a 1
set b 2
set c 3
namespace eval ::foo {
    # Define local variables
    local a b c
    set a 4
    set b 5
    set c 6
}
proc ::foo::bar1 {} {
    # Access global variables
    global a b c
    list $a $b $c
}
proc ::foo::bar2 {} {
    # Access local variables
    local a b c
    list $a $b $c
}
puts [::foo::bar1]; # global a b c
puts [::foo::bar2]; # local a b c
\end{lstlisting}
\tcblower
\begin{lstlisting}
1 2 3
4 5 6
\end{lstlisting}
\end{example}

\clearpage

\section{Default Values}
The command \cmdlink{default} assigns values to variables if they do not exist. 

\begin{syntax}
\command{default} \$varName \$value
\end{syntax}
\begin{args}
\$varName & Name of variable to set \\
\$value & Default value for variable
\end{args}

The example below shows how default values are only applied if the variable does not exist.

\begin{example}{Variable defaults}
\begin{lstlisting}
set a 5
default a 7; # equivalent to "if {![info exists a]} {set a 7}"
puts $a
unset a
default a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
7
\end{lstlisting}
\end{example}
\clearpage
\section{Variable Locks}
The command \cmdlink{lock} uses Tcl variable traces to make a read-only variable. 
This is especially useful for controlling a parameter study of an analysis from a top-level.
If attempting to modify a locked variable, it will throw a warning, but not an error.
You can lock array elements, but not an entire array.

\begin{syntax}
\command{lock} \$varName <\$value>
\end{syntax}
\begin{args}
\$varName & Variable name to lock.  \\
\$value & Value to lock variable at. Default self-locks (uses current value).
\end{args}

The command \cmdlink{unlock} unlocks previously locked variables so that they can be modified again.

\begin{syntax}
\command{unlock} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to unlock.
\end{args}

\begin{example}{Variable locks}
\begin{lstlisting}
lock a 5
set a 7; # throws warning to stderr channel
puts $a
unlock a
set a 7
puts $a
\end{lstlisting}
\tcblower
\begin{lstlisting}
failed to modify "a": read-only
5
7
\end{lstlisting}
\end{example}

\clearpage

\section{Variable-Object Ties}
As of Tcl version 8.6, there is no garbage collection for Tcl objects, they have to be removed manually with the ``destroy'' method. 
The command \cmdlink{tie} is a solution for this problem, using variable traces to destroy the corresponding object when the variable is unset or modified. 
For example, if an object is tied to a local procedure variable, the object will be destroyed when the procedure returns.
You can tie array elements, but not an entire array.

\begin{syntax}
\command{tie} \$refName <\$object>
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$object & Object to tie variable to. Default self-ties (uses current value).
\end{args}

In similar fashion to \cmdlink{unlock}, tied variables can be untied with the command \cmdlink{untie}.
\begin{syntax}
\command{untie} \$name1 \$name2 …
\end{syntax}
\begin{args}
\$name1 \$name2 … & Variables to untie.
\end{args}

\begin{example}{Variable-object ties}
\begin{lstlisting}
oo::class create foo {
    method hi {} {
        puts hi
    }
}
tie a [foo create bar]
set b $a; # alias variable
unset a; # triggers ``destroy''
$b hi; # throws error
\end{lstlisting}
\tcblower
\begin{lstlisting}
invalid command name "::bar"
\end{lstlisting}
\end{example}
\clearpage
\subsection{Reference Variables}
Valid reference variables for the \cmdlink{tie} command must match the following regular expression:
\begin{lstlisting}
(::+|\w+)+(\(\w+\))?
\end{lstlisting}
The one exception to this rule is the shared global reference ``\textbf{\texttt{\&}}''. 
This shared reference, regardless of scope, can be accessed with the command ``\textbf{\texttt{\cmdlink{\$\&}}}''.
\begin{syntax}
\command{\$\&} \$arg ...
\end{syntax}
\begin{args}
\$arg ... & Arguments for object.
\end{args}

Reference variables can also be referred to with the ``\texttt{\$@ref}'' syntax in the context of iterator functions. 
The engine for this is the command \cmdlink{refsub}, which performs ``\texttt{\$@ref}'' substitution on a given string, returning the updated string and all matched reference names. 
For example, ``\texttt{\$@ref}'' is converted to ``\texttt{\$\{@(ref)\}}''.
To escape a reference, especially for nested substitution, simply add more ``\texttt{@}'' symbols, like ``\texttt{\$@@ref}''.
\begin{syntax}
\command{refsub} \$string
\end{syntax}

\begin{example}{Reference Variable Substitution}
\begin{lstlisting}
lassign [refsub {$@& + $@x(1) $@@y}] string refs
puts $string
puts $refs
\end{lstlisting}
\tcblower
\begin{lstlisting}
${@(::vutil::&)} + ${@(x(1))} $@y
::vutil::& x(1)
\end{lstlisting}
\end{example}
A simple example of this is provided for the \subcmdlink[0]{new}{list} type, with the commands \cmdlink{leval} and \cmdlink{lexpr}.

\clearpage
\subsection{Garbage Collection Superclass}
The class \cmdlink{gcoo} is a TclOO superclass that includes garbage collection. 
This class is not exported, and not intended for direct use, as it is simply a template for classes with built-in garbage collection.
The constructor is configured as shown below, and ties the object to the specified reference variable, using \cmdlink{tie}.
\begin{syntax}
::vutil::\command{gcoo} new \$refName \\
::vutil::gcoo create \$name \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection. \\
\$name & Name of object.
\end{args}

In addition to tying the object to a reference variable in the superclass constructor, the \cmdlink{::vutil::gcoo} superclass also provides a method for copying the object to a new reference variable: ``\texttt{\methodlink[0]{gcoo}{-{}->}}''.
\begin{syntax}
\method{gcoo}{-{}->} \$refName
\end{syntax}
\begin{args}
\$refName & Name of reference variable for garbage collection.
\end{args}

Below is an example of how this superclass can be used to build garbage collection into a TclOO class. 
\begin{example}{Creating a class with garbage collection}
\begin{lstlisting}
oo::class create container {
    superclass ::vutil::gcoo
    variable myValue
    constructor {refName value} {
        set myValue $value
        next $refName
    }
    method set {value} {set myValue $value}
    method value {} {return $myValue}
}
proc wrap {value} {
    container new & $value
    return $&
}
[wrap {hello world}] --> x
puts [$x value]
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
\end{lstlisting}
\end{example}

\clearpage
\section{Variable-Object Links}
The command \cmdlink{link} links a global variable to a TclOO object, using the name of the object as the variable name. 
The value of the linked object variable is accessed by calling the TclOO object with no arguments (the ``unknown'' method), and writing to the object-variable calls the object's ``\texttt{=}'' method. 
Unsetting the linked object variable also calls the object's ``destroy'' method, and destroying the object unsets the linked object variable.
Linked object-variables are unlinked when the object is destroyed, but can also be unlinked with the command \cmdlink{unlink}.
\begin{syntax}
\command{link} \$object
\end{syntax}
\begin{syntax}
\command{unlink} \$object …
\end{syntax}
\begin{args}
\$object … & Object(s) to link/unlink.
\end{args}
\begin{example}{Linking an object variable}
\begin{lstlisting}
::oo::class create number {
    variable value
    constructor {args} {
        set value [uplevel 1 expr $args]
    }
    method unknown {args} {
        if {[llength $args] == 0} {
            return $value
        }
        next {*}$args
    }
    unexport unknown
    method = {args} {
        set value [uplevel 1 expr $args]
    }
    export =
}
link [tie a [number new 5]]; # garbage collection and obj-var link
puts [$a]; # 5
$a = 10 * [$a]
puts [$a]; # 50
incr $a
puts [subst $$a]; # 51
\end{lstlisting}
\tcblower
\begin{lstlisting}
5
50
51
\end{lstlisting}
\end{example}
\clearpage
\section{Object Variable Class}
The TclOO class \cmdlink{var} is a subclass of \cmdlink{::vutil::gcoo}, that also sets up an object variable link with \cmdlink{link}. 
So, in addition to the copy method ``\texttt{\methodlink[0]{gcoo}{-{}->}}'', object variables can be manipulated directly with Tcl commands, and calling the object variable directly as a command with no arguments (e.g. \texttt{[\$varObj]}) returns the object variable value.

\begin{syntax}
\command{var} new \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable. \\
\$value & Value to set object variable to. 
\end{args}

\begin{example}{Object variables with garbage collection}
\begin{lstlisting}
# Example showing how object variables behave in procedures
proc foo {value} {
    # Create object with reference variable "result"
    var new result $value
    append $result { world}
    return [list $result [$result]]; # Returns name and value of object
}
set result [foo hello]; # Not the same "result"
lassign $result name value
puts $value; # hello world
puts [info object isa object $name]; # 0 (object was deleted when procedure returned)
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello world
0
\end{lstlisting}
\end{example}
\clearpage
\subsection{Metadata Methods}
Additional information about the object variable can be accessed with object variable methods:

The method \methodlink[0]{var}{info} accesses all object variable metadata. 
Fields ``exists'' and ``type'' always exist, and ``value'' is populated when the variable is initialized.
\begin{syntax}
\method{var}{info} <\$field>
\end{syntax}
\begin{args}
\$field & Info field to get. Default returns dictionary of all info. \\
\end{args}

The method \methodlink[0]{var}{print} is a short-hand way to print the value of the variable to screen.
\begin{syntax}
\method{var}{print} <-nonewline> <\$channelID>
\end{syntax}
\begin{args}
-nonewline & Option to print without newline. \\
\$channelID & Channel ID open for writing. Default stdout.
\end{args}
\begin{example}{Printing the value of a variable}
\begin{lstlisting}
var new x {Hello World}
puts [$x info]
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
exists 1 type var value {Hello World}
Hello World
\end{lstlisting}
\end{example}


\clearpage
\subsection{Direct Assignment Operators}
In addition to being able to manipulate object variables directly with Tcl commands, variables can also be manipulated with object variable operators.

The operators ``\texttt{\methodlink[0]{var}{=}}'' and ``\texttt{\methodlink[0]{var}{:=}}'' assign the value of the object variable, and return the name of the object.
\begin{syntax}
\method{var}{=} \$value
\end{syntax}
\begin{syntax}
\method{var}{:=} \$expr
\end{syntax}
\begin{args}
\$value & Value to set object variable to. \\
\$expr & Math expression to evaluate and set as object value. 
\end{args}
The operator ``\texttt{\methodlink[0]{var}{<-}}'' assigns the value of the object directly from another object variable of the same class, and, like the operator  ``\texttt{\methodlink[0]{var}{=}}'', returns the name of the object.
\begin{syntax}
\method{var}{<-} \$otherVarObj 
\end{syntax}
\begin{args}
\$otherVarObj & Other object variable to assign value from.
\end{args}

The example below demonstrates the myriad of ways object variables can be manipulated:
\begin{example}{Object variable manipulation features}
\begin{lstlisting}
var new x; # Create blank variable $x
[$x --> y] = 5; # Copy $x to $y, and set to 5
[var new z] <- [$x <- $y]; # Create $z and set to x after setting $x to $y.
$z := {[$z] + [$x]}; # Add $x to $z
append $y [set $x 0]; # Append $y the value of $x after setting $x to 0
puts [list [$x] [$y] [$z]]
\end{lstlisting}
\tcblower
\begin{lstlisting}
0 50 10
\end{lstlisting}
\end{example}

\clearpage
\section{Object Variable Types}
The TclOO class \cmdlink{var} acts as a superclass for a pure-Tcl type system. Type classes are created and managed through the command ensemble \cmdlink{type}.
\begin{syntax}
\command{type} \$subcommand \$arg ...
\end{syntax}
\begin{args}
\$subcommand & Subcommand name. \\
\$arg ... & Arguments for subcommand.
\end{args}

New type classes can be created using the subcommands \subcmdlink[0]{type}{new} or \subcmdlink[0]{type}{create}.
Both subcommands create a class that is a subclass of ``\texttt{::vutil::var}'', with a private method \textit{Type} that returns the corresponding type.
If creating a type class with the subcommand \subcmdlink[0]{type}{new}, the resulting class will be named ``\texttt{::vutil::type.\$type}''.
\begin{syntax}
\subcommand{type}{new} \$type \$defScript \\
\subcommand{type}{create} \$type \$name \$defScript
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$name & Name of class. \\
\$defScript & Class definition script. 
\end{args}

To demonstrate how easy it is to create a type class, below is the code used to create the \subcmdlink[0]{new}{string} type.
\begin{example}{Creating a simple type}
\begin{lstlisting}
type new string {
    method info {args} {
        set (length) [my length]
        next {*}$args
    }
    method length {} {
        string length $(value)
    }
    method @ {i} {
        string index $(value) $i
    }
    export @
}
\end{lstlisting}
\end{example}

Note that the value is stored in the blank array name ``value''. 
The blank array is used to store all the object variable properties, and is what is returned with the method ``info''.
By default, from the superclass ``\texttt{::vutil::var}'', there are three properties: (value), (exists), and (type)

\clearpage
\subsection{Type Queries}
A list of all defined types can be queried with the subcommand \subcmdlink[0]{type}{names}. 
\begin{syntax}
\subcommand{type}{names}
\end{syntax}

The existence of a type can be queried with the subcommand \subcmdlink[0]{type}{exists}, and 
the class associated with a type can be queried with the subcommand \subcmdlink[0]{type}{class}. 
\begin{syntax}
\subcommand{type}{exists} \$type
\end{syntax}
\begin{syntax}
\subcommand{type}{class} \$type
\end{syntax}
\begin{args}
\$type & Name of type. 
\end{args}

The subcommand \subcmdlink[0]{type}{isa} checks if an object is of a specific type or of one of its subtypes.
If the type or object does not exist, this command will return an error.
Similarly, the subcommand \subcmdlink[0]{type}{assert} returns an error if an object is not of a specific type or of one its subtypes.

\begin{syntax}
\subcommand{type}{isa} \$type \$object
\end{syntax}
\begin{syntax}
\subcommand{type}{assert} \$type \$object
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$object & Name of object.
\end{args}

\begin{example}{Type assertion}
\begin{lstlisting}
proc foo {bar} {
    type assert list $bar
    $bar @ end
}
\end{lstlisting}
\end{example}

\clearpage
\subsection{Creating Type Variables}
Classes defined by \cmdlink{type} only have the constructor method \textit{new}, so as a convenience, the command \cmdlink{new} creates a new variable object of a specified type. If the reference name provided is blank, it will simply return the value after passing it through the datatype's data validation.

\begin{syntax}
\command{new} \$type \$refName <\$value>
\end{syntax}
\begin{args}
\$type & Name of type. \\
\$refName & Name of reference variable to tie to object. Blank to return value. \\
\$value & Value to set object variable to.
\end{args}

Now you can easily create variables in Tcl with a specified type!
\begin{example}{Creating a new \subcmdlink[0]{new}{string} object variable}
\begin{lstlisting}
new string x
set $x {hello world}
puts [$x length]
puts [$x info]
puts [$x @ end]
$x print
\end{lstlisting}
\tcblower
\begin{lstlisting}
11
exists 1 length 11 type string value {hello world}
d
hello world
\end{lstlisting}
\end{example}

\clearpage
\section{Type Library}
This package provides a few basic object variable types: \subcmdlink[0]{new}{var}, \subcmdlink[0]{new}{string}, \subcmdlink[0]{new}{bool}, \subcmdlink[0]{new}{int}, \subcmdlink[0]{new}{float}, \subcmdlink[0]{new}{list}, and \subcmdlink[0]{new}{dict}.

\subsection{Type ``var''}
The type ``\subcmdlink[0]{new}{var}'' is just an alternative way to create an object variable (same syntax as ``new'' method for \cmdlink{var} class).
It does not have any additional metadata or methods.
\begin{syntax}
\subcommand{new}{var} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Value to set object variable to.
\end{args}
\subsection{Type ``string''}
The type ``\subcmdlink[0]{new}{string}'' does not do any validation on input (because in Tcl, ``everything is a string''), but additionally provides methods for getting string length and string index, and adds the field ``length'' to the variable info.
\begin{syntax}
\subcommand{new}{string} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & String value.
\end{args}
The method \textit{length} returns the string length. This is the same as ``\texttt{\$stringObj info length}''.
\begin{syntax}
\$stringObj length
\end{syntax}
The method ``\texttt{@}'' returns the character at the specified index.
\begin{syntax}
\$stringObj @ \$i
\end{syntax}
\begin{args}
\$i & String index. 
\end{args}
\clearpage
\subsection{Type ``bool'' (boolean)}
The type ``\subcmdlink[0]{new}{bool}'' validates that the input is a valid boolean, passing input through the Tcl \textit{::tcl::mathfunc::bool} command.
\begin{syntax}
\subcommand{new}{bool} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Boolean value.
\end{args}

In addition to the standard object variable methods, the ``bool'' type provides a shorthand if-statement control flow method:
\begin{syntax}
\$boolObj "?" \$body1 <":" \$body2> 
\end{syntax}
\begin{args}
\$body1 & Body to evaluate if boolean is true. \\
\$body2 & Body to evaluate if boolean is false (optional, required with ``\texttt{:}'' keyword).
\end{args}

\begin{example}{String and boolean example}
\begin{lstlisting}
# proc with types
proc foo {a b c} {
    new string a $a
    new string b $b
    new bool c $c
    $c ? $a : $b
}
puts [foo hello world true]; # hello
puts [foo hello world false]; # world
\end{lstlisting}
\tcblower
\begin{lstlisting}
hello
world
\end{lstlisting}
\end{example}
\clearpage
\subsection{Type ``int'' (integer)}
The type ``\subcmdlink[0]{new}{int}'' validates that the input is a valid integer, and additionally has increment/decrement methods.
\begin{syntax}
\subcommand{new}{int} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Integer value.
\end{args}
In addition to the standard operators, this type also has two short-hand increment/decrement operators, ``\texttt{++}'' and ``\texttt{-{}-}'', which simply increment or decrement the integer object by 1.
\begin{syntax}
\$intObj ++ 
\end{syntax}
\begin{syntax}
\$intObj -{}-
\end{syntax}

\begin{example}{Integer example (for loop)}
\begin{lstlisting}
for {new int i 0} {[$i] < 3} {$i ++} {
    puts [$i]
}
\end{lstlisting}
\tcblower
\begin{lstlisting}
0
1
2
\end{lstlisting}
\end{example}
\clearpage

\subsection{Type ``float'' (double-precision floating-point decimal)}
The type ``\subcmdlink[0]{new}{float}'' validates that input is a double-precision floating-point number, passing input through the Tcl \textit{::tcl::mathfunc::double} command.
\begin{syntax}
\subcommand{new}{float} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Float value.
\end{args}

\begin{example}{Float example (procedure with type assertion)}
\begin{lstlisting}
# Harmonic mean of two numbers (converts to float)
proc hmean {x y} {
    new float x $x
    new float y $y
    [new float z] := {2*[$x]*[$y]}
    if {[$z] != 0} {
        $z := {[$z] / ([$x] + [$y])}
    }
    return [$z]
}
puts [hmean 1 2]; # 1.3333
\end{lstlisting}
\tcblower
\begin{lstlisting}
1.3333333333333333
\end{lstlisting}
\end{example}

\clearpage
\subsection{Type ``list''}
The type ``\subcmdlink[0]{new}{list}'' validates that the input is a list, and additionally passes input from its main ``\texttt{:=}'' operator through the \cmdlink{lexpr} command. All self-referencing operators pass through the Tcl \textit{lmap} command.
\begin{syntax}
\subcommand{new}{list} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & List value.
\end{args}
The method \textit{length} returns the list length. This is the same as ``\texttt{\$listObj info length}''.
\begin{syntax}
\$listObj length
\end{syntax}
The method ``\texttt{@}'' acts as either list indexing or list setting, depending on whether the ``\texttt{=}'' or ``\texttt{:=}'' keywords are used.
If indexing, it returns the value at the specified index. 
If setting, it sets the value and returns the object name.
\begin{syntax}
\$listObj @ \$i ... <''='' \$value | '':='' \$expr>
\end{syntax}
\begin{args}
\$i ... & List indices. \\
\$value & Value to set. \\
\$expr & Math expression, passed through \cmdlink{lexpr} command.
\end{args}

\begin{example}{List example}
\begin{lstlisting}
[new list list1] = {hello world}
puts [$list1 length]; # 2
$list1 @ 0 = "hey"
$list1 @ 1 = "there"
$list1 @ end+1 = "world"
puts [$list1 @ end]; # world
set a 5
$list1 @ end+1 := {$a + 1}
puts [$list1 info]; # exists 1 length 4 type list value {hey there world 6}
\end{lstlisting}
\tcblower
\begin{lstlisting}
2
world
exists 1 length 4 type list value {hey there world 6}
\end{lstlisting}
\end{example}
\clearpage
\subsection{Type ``dict''}
The type ``\subcmdlink[0]{new}{dict}'' validates that the input is a Tcl dictionary, and provides methods for getting/setting/unsetting dictionary values, checking if values exist, and getting the dictionary size. Additionally, it adds the field ``size'' to the variable info. 
\begin{syntax}
\subcommand{new}{dict} \$refName <\$value>
\end{syntax}
\begin{args}
\$refName & Name of reference variable to tie to object. \\
\$value & Dictionary value.
\end{args}
The method \$dictObj size returns the dictionary size. This is the same as ``\texttt{\$dictObj info size}''.
\begin{syntax}
\$dictObj size
\end{syntax}
The methods \textit{set} and \textit{unset} set and unset values in the dictionary, and return the object name.
The method \textit{get} returns values in the dictionary, and the method \textit{exists} returns whether the key pairing exists.
\begin{syntax}
\$dictObj set \$key ... \$value
\end{syntax}
\begin{syntax}
\$dictObj unset \$key ...
\end{syntax}
\begin{syntax}
\$dictObj get \$key ...
\end{syntax}
\begin{syntax}
\$dictObj exists \$key ...
\end{syntax}
\begin{args}
\$key ... & Dictionary keys. \\
\$value & Value to set. 
\end{args}
\clearpage
Below is an example of how the dictionary variable type can streamline basic dictionary queries.
Note that not all of the subcommands of the Tcl \cmdlink{dict} are provided as dictionary object methods, but because it is an object variable, it can still be manipulated using normal \textit{dict} commands as well.
\begin{example}{Dictionary example}
\begin{lstlisting}
# Create dictionary record
new dict record {
    name {John Doe}
    address {
        streetAddress {123 Main Street}
        city {New York}
        state {NY}
        zip {10001}
    }
    phone {555-1234} 
}

# Get values
puts [$record size]; # Number of keys (3)
puts [$record get name]; # John Doe
# Set/unset and get
$record set address street [$record get address streetAddress]
$record unset address streetAddress
puts [$record get address street]; # 123 Main Street
puts [$record exists address streetAddress]; # 0
# Manipulate with normal dict commands
dict lappend $record name Smith
puts [$record get name]
\end{lstlisting}
\tcblower
\begin{lstlisting}
3
John Doe
123 Main Street
0
John Doe Smith
\end{lstlisting}
\end{example}
\clearpage
\section{List Object Mapping}
Using the \cmdlink{refsub} syntax, you can create powerful wrapper commands. As a demonstration, this package provides two simple list object mapping commands: \cmdlink{leval} and \cmdlink{lexpr}.
The \cmdlink{lexpr} command additionally is built-in to the ``\texttt{:=}'' operator for the \subcmdlink[0]{new}{list} type.

\begin{syntax}
\command{leval} \$body <"-{}->" \$refName>
\end{syntax}
\begin{syntax}
\command{lexpr} \$expr <"-{}->" \$refName>
\end{syntax}
\begin{args}
\$body & Body with list object references. \\
\$expr & Tcl math expression with list object references. \\
\$refName & Optional reference variable to tie resulting list to. Blank to return value.
\end{args}

\begin{example}{Element-wise math}
\begin{lstlisting}
new list x {1 2 3}
new list y {4 5 6}
lexpr {$@x + $@y} --> z
$z := {double($@z)}
$z print
\end{lstlisting}
\tcblower
\begin{lstlisting}
5.0 7.0 9.0
\end{lstlisting}
\end{example}

\begin{example}{Zip a list together (modified from \url{https://www.tcl-lang.org/man/tcl/TclCmd/lmap.htm})}
\begin{lstlisting}
new list list1 {a b c d}
new list list2 {1 2 3 4}
leval {list $@list1 $@list2} --> zipped
$zipped print
\end{lstlisting}
\tcblower
\begin{lstlisting}
{a 1} {b 2} {c 3} {d 4}
\end{lstlisting}
\end{example}
\clearpage
{\large \printindex}
\end{document}
































